<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gematria Polyhedron Matrix</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f0;
      color: #333;
      padding: 24px;
      min-height: 100vh;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 { font-size: 24px; margin-bottom: 8px; color: #333; }
    .subtitle { color: #666; margin-bottom: 24px; }

    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
      align-items: center;
    }
    select, button, input {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      color: #333;
      padding: 8px 12px;
      font-size: 14px;
    }
    button {
      background: #6b5b95;
      border-color: #6b5b95;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #5a4a84; }
    button.secondary {
      background: #fff;
      color: #6b5b95;
      border-color: #6b5b95;
    }

    .matrix-container {
      background: #fff;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 24px;
      display: flex;
      justify-content: center;
      overflow-x: auto;
    }

    .legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }
    .legend-item {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
    }
    .legend-label { font-size: 12px; color: #666; margin-bottom: 4px; }
    .legend-value { font-weight: bold; color: #333; }
    .legend-desc { font-size: 11px; color: #888; margin-top: 4px; }

    .color-preview {
      width: 100%;
      height: 40px;
      border-radius: 4px;
      margin-top: 8px;
      border: 1px solid #ccc;
    }

    .info-box {
      background: #f0f0e8;
      border: 1px solid #d0d0c0;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 24px;
    }
    .info-box h3 { color: #6b5b95; margin-bottom: 8px; }
    .info-box p, .info-box li { color: #555; font-size: 13px; line-height: 1.6; }
    .info-box code { background: #e0e0d8; padding: 2px 6px; border-radius: 4px; color: #6b5b95; }

    .config-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      margin-top: 12px;
    }
    .config-btn {
      padding: 6px;
      font-size: 11px;
      text-align: center;
    }
    .config-btn.active {
      background: #6b5b95;
      color: #fff;
    }

    .export-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .variation-indicator {
      display: flex;
      gap: 4px;
      margin-top: 8px;
    }
    .variation-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ddd;
    }
    .variation-dot.active {
      background: #6b5b95;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gematria Polyhedron Matrix</h1>
    <p class="subtitle">Triangular tessellation with CMYK color encoding</p>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-label">Gematria Combo</div>
        <div class="legend-value" id="currentCombo">555/666/111/111</div>
        <div class="legend-desc">Hebrew / English / Simple / Aik Bekar⁹</div>
      </div>
      <div class="legend-item">
        <div class="legend-label">CMYK → Hex Color</div>
        <div class="legend-value" id="cmykValues">C:56% M:67% Y:11% K:11%</div>
        <div class="color-preview" id="colorPreview"></div>
      </div>
      <div class="legend-item">
        <div class="legend-label">Current Configuration</div>
        <div class="legend-value" id="configName">a-*-z</div>
        <div class="legend-desc" id="configDesc">A at start, * in middle, Z at end</div>
        <div class="config-grid">
          <button class="config-btn active" data-config="a-*-z">a-*-z</button>
          <button class="config-btn" data-config="*-a-z">*-a-z</button>
          <button class="config-btn" data-config="a-z-*">a-z-*</button>
          <button class="config-btn" data-config="z-*-a">z-*-a</button>
          <button class="config-btn" data-config="*-z-a">*-z-a</button>
          <button class="config-btn" data-config="z-a-*">z-a-*</button>
        </div>
      </div>
      <div class="legend-item">
        <div class="legend-label">Animation State</div>
        <div class="legend-value">Variation <span id="variationNum">1</span>/2</div>
        <div class="legend-desc">Frame <span id="frameNum">1</span>/6</div>
        <div class="variation-indicator">
          <div class="variation-dot active" id="dot1"></div>
          <div class="variation-dot" id="dot2"></div>
        </div>
      </div>
    </div>

    <div class="controls">
      <select id="phraseSelect">
        <option value="555/666/111/111">stunner (555/666/111/111)</option>
        <option value="111/666/111/99">which (111/666/111/99)</option>
        <option value="333/666/111/99">act shah high (333/666/111/99)</option>
        <option value="777/666/111/99">xbox add salad (777/666/111/99)</option>
        <option value="1111/666/111/99">hiawatha (1111/666/111/99)</option>
        <option value="8888/6666/1111/1111">therapeutic (8888/6666/1111/1111)</option>
      </select>
      <button id="playPause">⏸ Pause</button>
      <button id="prevFrame" class="secondary">◀ Prev</button>
      <button id="nextFrame" class="secondary">Next ▶</button>
      <div class="export-buttons">
        <button id="exportGif">Export GIF</button>
        <button id="exportWebm">Export WebM</button>
        <button id="exportSvg">Export SVG+HTML</button>
      </div>
    </div>

    <div class="matrix-container">
      <svg id="matrixSvg" width="900" height="400" viewBox="0 0 900 400"></svg>
    </div>

    <div class="info-box">
      <h3>Configuration Structure</h3>
      <p>Each configuration arranges A-Z + * in a 9×3 triangle grid (27 positions):</p>
      <ul style="margin-left: 20px; margin-top: 8px;">
        <li><code>a-*-z</code>: A(1) → *(14) → Z(27) - Standard order with * in middle</li>
        <li><code>*-a-z</code>: *(1) → A(2) → Z(27) - Asterisk leads</li>
        <li><code>a-z-*</code>: A(1) → Z(26) → *(27) - Asterisk at end</li>
        <li><code>z-*-a</code>: Z(1) → *(14) → A(27) - Reverse with * in middle</li>
        <li><code>*-z-a</code>: *(1) → Z(2) → A(27) - Reverse, asterisk leads</li>
        <li><code>z-a-*</code>: Z(1) → A(26) → *(27) - Reverse, asterisk at end</li>
      </ul>
      <h3 style="margin-top: 16px;">Animation Mirroring</h3>
      <p>For each config, 2 variations are created:</p>
      <ul style="margin-left: 20px; margin-top: 8px;">
        <li><strong>Variation 1:</strong> Base polycolumn (3-row → 6-row via X/XY mirror) + Y-mirror pair</li>
        <li><strong>Variation 2:</strong> X-mirrored polycolumns (inverted shape)</li>
      </ul>
      <p style="margin-top: 8px;">Each variation displays for 6 frames, then cycles. 6 configs × 2 variations = 12 total animation states.</p>
    </div>
  </div>

  <script>
    // Triangle geometry
    const TRI_WIDTH = 80;
    const TRI_HEIGHT = TRI_WIDTH * Math.sqrt(3) / 2;
    const COLS = 9;  // 9 triangles per row
    const ROWS = 3;  // 3 rows
    const TOTAL_POSITIONS = 27; // 26 letters + 1 asterisk

    // Alphabet + asterisk
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ*';

    // Configuration definitions
    // Each config defines how to arrange the 27 symbols (A-Z + *)
    const CONFIGS = {
      'a-*-z': {
        name: 'a-*-z',
        desc: 'A at start, * in middle, Z at end',
        // Standard order: A-M, *, N-Z
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[pos];        // A-M (positions 0-12)
          if (pos === 13) return '*';                 // * (position 13, middle)
          return ALPHABET[pos - 1];                   // N-Z (positions 14-26, shifted)
        }
      },
      '*-a-z': {
        name: '*-a-z',
        desc: '* at start, A-Z follows',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[pos - 1];
        }
      },
      'a-z-*': {
        name: 'a-z-*',
        desc: 'A-Z in order, * at end',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[pos];
        }
      },
      'z-*-a': {
        name: 'z-*-a',
        desc: 'Z at start, * in middle, A at end',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[25 - pos];   // Z-N
          if (pos === 13) return '*';                 // *
          return ALPHABET[25 - (pos - 1)];           // M-A
        }
      },
      '*-z-a': {
        name: '*-z-a',
        desc: '* at start, Z-A follows (reverse)',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[26 - pos];
        }
      },
      'z-a-*': {
        name: 'z-a-*',
        desc: 'Z-A in order, * at end',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[25 - pos];
        }
      }
    };

    const CONFIG_KEYS = Object.keys(CONFIGS);

    // Current state
    let currentCombo = [555, 666, 111, 111];
    let currentConfig = 'a-*-z';
    let currentVariation = 0; // 0 or 1
    let currentFrame = 0;     // 0-5
    let isPlaying = true;
    let animationTimer = null;

    // Highlighted positions (diagonal pattern through middle, like the image)
    const HIGHLIGHT_POSITIONS = [4, 13, 14, 18, 19, 20, 21, 22]; // E, *, N, R, S, T, U, V

    // Convert gematria combo to CMYK percentages
    function comboToCMYK(combo) {
      // Extract first 3 digits and convert to percentage
      const toPercent = (val) => {
        const digits = val.toString().slice(0, 3);
        return Math.round(parseFloat(digits) / 10);
      };
      return {
        c: toPercent(combo[0]),
        m: toPercent(combo[1]),
        y: toPercent(combo[2]),
        k: toPercent(combo[3])
      };
    }

    // Convert CMYK to RGB
    function cmykToRgb(c, m, y, k) {
      c = c / 100;
      m = m / 100;
      y = y / 100;
      k = k / 100;
      return {
        r: Math.round(255 * (1 - c) * (1 - k)),
        g: Math.round(255 * (1 - m) * (1 - k)),
        b: Math.round(255 * (1 - y) * (1 - k))
      };
    }

    // RGB to Hex
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    // Get color from combo
    function getColorFromCombo(combo) {
      const cmyk = comboToCMYK(combo);
      const rgb = cmykToRgb(cmyk.c, cmyk.m, cmyk.y, cmyk.k);
      return { cmyk, rgb, hex: rgbToHex(rgb.r, rgb.g, rgb.b) };
    }

    // Get letter color based on row and letter
    function getLetterColor(symbol, row) {
      if (symbol === '*') return '#2e8b57'; // Green for asterisk

      const idx = ALPHABET.indexOf(symbol);

      // Green: E, F, N
      if (['E', 'F', 'N'].includes(symbol)) return '#2e8b57';

      // Red: R-Z (indices 17-25) when in highlighted area
      if (idx >= 17 && idx <= 25) return '#c41e3a';

      // Blue: default
      return '#1e4d8c';
    }

    // Generate triangle grid positions
    function generateGrid() {
      const triangles = [];
      const offsetX = 50;
      const offsetY = 50;

      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const isUpPointing = (col % 2 === 0);
          const x = offsetX + col * (TRI_WIDTH / 2);
          const y = offsetY + row * TRI_HEIGHT;

          triangles.push({
            row,
            col,
            x,
            y,
            pointing: isUpPointing ? 'up' : 'down',
            index: row * COLS + col
          });
        }
      }
      return triangles;
    }

    // Get triangle SVG path
    function getTrianglePath(tri) {
      const { x, y, pointing } = tri;
      const halfWidth = TRI_WIDTH / 2;

      if (pointing === 'up') {
        // Up-pointing: apex at top
        return `M ${x} ${y + TRI_HEIGHT} L ${x + halfWidth} ${y} L ${x + TRI_WIDTH} ${y + TRI_HEIGHT} Z`;
      } else {
        // Down-pointing: apex at bottom
        return `M ${x} ${y} L ${x + TRI_WIDTH} ${y} L ${x + halfWidth} ${y + TRI_HEIGHT} Z`;
      }
    }

    // Apply mirroring transformation based on variation
    function applyVariation(triangles, variation) {
      if (variation === 0) return triangles;

      // Variation 1: X-mirror (flip horizontally)
      const maxX = Math.max(...triangles.map(t => t.x));
      return triangles.map(t => ({
        ...t,
        x: maxX - t.x,
        // Also reverse the index for letter mapping
        mirroredIndex: (ROWS - 1 - t.row) * COLS + (COLS - 1 - t.col)
      }));
    }

    // Render the SVG
    function render() {
      const svg = document.getElementById('matrixSvg');
      const config = CONFIGS[currentConfig];
      const color = getColorFromCombo(currentCombo);

      // Update UI
      document.getElementById('currentCombo').textContent = currentCombo.join('/');
      document.getElementById('cmykValues').textContent =
        `C:${color.cmyk.c}% M:${color.cmyk.m}% Y:${color.cmyk.y}% K:${color.cmyk.k}%`;
      document.getElementById('colorPreview').style.backgroundColor = color.hex;
      document.getElementById('configName').textContent = config.name;
      document.getElementById('configDesc').textContent = config.desc;
      document.getElementById('variationNum').textContent = currentVariation + 1;
      document.getElementById('frameNum').textContent = currentFrame + 1;

      // Update config buttons
      document.querySelectorAll('.config-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.config === currentConfig);
      });

      // Update variation dots
      document.getElementById('dot1').classList.toggle('active', currentVariation === 0);
      document.getElementById('dot2').classList.toggle('active', currentVariation === 1);

      // Generate base grid
      let triangles = generateGrid();

      // Apply variation transformation
      triangles = applyVariation(triangles, currentVariation);

      // Build SVG
      let svgContent = `<rect width="100%" height="100%" fill="#f8f8f4"/>`;

      // Draw triangles
      triangles.forEach(tri => {
        const idx = tri.mirroredIndex !== undefined ? tri.mirroredIndex : tri.index;
        const symbol = config.getSymbol(idx);
        const path = getTrianglePath(tri);
        const isHighlighted = HIGHLIGHT_POSITIONS.includes(idx);
        const letterColor = getLetterColor(symbol, tri.row);

        // Fill color
        const fill = isHighlighted ? color.hex : '#f8f8f4';
        const fillOpacity = isHighlighted ? 0.5 : 1;

        svgContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#333" stroke-width="2"/>`;

        // Letter position
        const halfWidth = TRI_WIDTH / 2;
        let textX, textY;

        if (tri.pointing === 'up') {
          textX = tri.x + halfWidth;
          textY = tri.y + TRI_HEIGHT * 0.6;
        } else {
          textX = tri.x + halfWidth;
          textY = tri.y + TRI_HEIGHT * 0.4;
        }

        svgContent += `
          <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                font-family="Arial, sans-serif" font-size="18" font-weight="bold" fill="${letterColor}">
            ${symbol}
          </text>
        `;
      });

      svg.innerHTML = svgContent;
    }

    // Animation loop
    function animate() {
      if (!isPlaying) return;

      currentFrame++;
      if (currentFrame >= 6) {
        currentFrame = 0;
        currentVariation++;
        if (currentVariation >= 2) {
          currentVariation = 0;
          // Move to next config
          const idx = CONFIG_KEYS.indexOf(currentConfig);
          currentConfig = CONFIG_KEYS[(idx + 1) % CONFIG_KEYS.length];
        }
      }

      render();
      animationTimer = setTimeout(animate, 500);
    }

    // Start/stop animation
    function toggleAnimation() {
      isPlaying = !isPlaying;
      document.getElementById('playPause').textContent = isPlaying ? '⏸ Pause' : '▶ Play';
      if (isPlaying) animate();
      else if (animationTimer) clearTimeout(animationTimer);
    }

    // Event handlers
    document.getElementById('playPause').addEventListener('click', toggleAnimation);

    document.getElementById('prevFrame').addEventListener('click', () => {
      currentFrame--;
      if (currentFrame < 0) {
        currentFrame = 5;
        currentVariation--;
        if (currentVariation < 0) {
          currentVariation = 1;
          const idx = CONFIG_KEYS.indexOf(currentConfig);
          currentConfig = CONFIG_KEYS[(idx - 1 + CONFIG_KEYS.length) % CONFIG_KEYS.length];
        }
      }
      render();
    });

    document.getElementById('nextFrame').addEventListener('click', () => {
      currentFrame++;
      if (currentFrame >= 6) {
        currentFrame = 0;
        currentVariation++;
        if (currentVariation >= 2) {
          currentVariation = 0;
          const idx = CONFIG_KEYS.indexOf(currentConfig);
          currentConfig = CONFIG_KEYS[(idx + 1) % CONFIG_KEYS.length];
        }
      }
      render();
    });

    document.querySelectorAll('.config-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentConfig = btn.dataset.config;
        currentVariation = 0;
        currentFrame = 0;
        render();
      });
    });

    document.getElementById('phraseSelect').addEventListener('change', (e) => {
      currentCombo = e.target.value.split('/').map(Number);
      render();
    });

    // Export handlers
    document.getElementById('exportSvg').addEventListener('click', () => {
      const svg = document.getElementById('matrixSvg');
      const svgData = new XMLSerializer().serializeToString(svg);

      const html = `<!DOCTYPE html>
<html>
<head>
  <title>Gematria Polyhedron - ${currentConfig}</title>
  <style>body{margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;background:#f5f5f0;}</style>
</head>
<body>
${svgData}
</body>
</html>`;

      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `gematria-${currentConfig}-v${currentVariation + 1}.html`;
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById('exportGif').addEventListener('click', () => {
      alert('GIF export: Capture all 12 variations (6 configs × 2 variations) at 6 frames each.\nUse browser dev tools or a screen recorder to capture the animation.');
    });

    document.getElementById('exportWebm').addEventListener('click', () => {
      alert('WebM export: Use MediaRecorder API or screen capture to record the SVG animation as video.');
    });

    // Initialize
    render();
    animate();
  </script>
</body>
</html>
