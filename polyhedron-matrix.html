<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gematria Polyhedron Tessellation</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f0;
      color: #333;
      min-height: 100vh;
      overflow: hidden;
    }

    .controls-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(255,255,255,0.95);
      border-bottom: 2px solid #333;
      padding: 12px 24px;
      z-index: 100;
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-label {
      font-size: 11px;
      color: #666;
      text-transform: uppercase;
    }

    select, button {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      color: #333;
      padding: 6px 10px;
      font-size: 13px;
    }

    button {
      background: #6b5b95;
      border-color: #6b5b95;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #5a4a84; }
    button.secondary {
      background: #fff;
      color: #6b5b95;
      border-color: #6b5b95;
    }

    .info-display {
      font-family: monospace;
      font-size: 12px;
      background: #f0f0e8;
      padding: 4px 8px;
      border-radius: 4px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #333;
    }

    .tessellation-container {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #tessellationSvg {
      /* Static and centered */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="controls-overlay">
    <div class="control-group">
      <span class="control-label">Phrase</span>
      <select id="phraseSelect">
        <option value="555/666/111/111">stunner (555/666/111/111)</option>
        <option value="111/666/111/99">which (111/666/111/99)</option>
        <option value="333/666/111/99">act shah high (333/666/111/99)</option>
        <option value="777/666/111/99">xbox add salad (777/666/111/99)</option>
        <option value="1111/666/111/99">hiawatha (1111/666/111/99)</option>
        <option value="8888/6666/1111/1111">therapeutic (8888/6666/1111/1111)</option>
      </select>
    </div>

    <div class="control-group">
      <span class="control-label">Config</span>
      <span class="info-display" id="configName">a-*-z</span>
    </div>

    <div class="control-group">
      <span class="control-label">Variation</span>
      <span class="info-display" id="variationInfo">1/2</span>
    </div>

    <div class="control-group">
      <span class="control-label">Frame</span>
      <span class="info-display" id="frameInfo">1/6</span>
    </div>

    <div class="control-group">
      <span class="control-label">CMYK</span>
      <span class="info-display" id="cmykInfo">56/67/11/11</span>
      <div class="color-swatch" id="colorSwatch"></div>
    </div>

    <div class="control-group">
      <button id="playPause">⏸</button>
      <button id="prevVar" class="secondary">◀</button>
      <button id="nextVar" class="secondary">▶</button>
    </div>

    <div class="control-group">
      <button id="exportGif">GIF</button>
      <button id="exportWebm">WebM</button>
      <button id="exportSvg">SVG</button>
    </div>
  </div>

  <div class="tessellation-container">
    <svg id="tessellationSvg"></svg>
  </div>

  <script>
    // Constants
    const TRI_SIZE = 32;
    const TRI_HEIGHT = TRI_SIZE * Math.sqrt(3) / 2;
    const COLS = 9;    // Triangles per row in base polyhedron
    const BASE_ROWS = 3; // Base polyhedron rows

    // Alphabet
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // 6 configurations
    const CONFIGS = {
      'a-*-z': {
        name: 'a-*-z',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[pos];
          if (pos === 13) return '*';
          return ALPHABET[pos - 1];
        }
      },
      '*-a-z': {
        name: '*-a-z',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[pos - 1];
        }
      },
      'a-z-*': {
        name: 'a-z-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[pos];
        }
      },
      'z-*-a': {
        name: 'z-*-a',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[25 - pos];
          if (pos === 13) return '*';
          return ALPHABET[25 - (pos - 1)];
        }
      },
      '*-z-a': {
        name: '*-z-a',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[26 - pos];
        }
      },
      'z-a-*': {
        name: 'z-a-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[25 - pos];
        }
      }
    };

    const CONFIG_KEYS = Object.keys(CONFIGS);

    // State
    let currentCombo = [555, 666, 111, 111];
    let currentConfigIndex = 0;
    let currentVariation = 0; // 0 or 1
    let currentFrame = 0;
    let isPlaying = true;
    let animationTimer = null;

    // Highlighted positions (diagonal through middle - E, *, N, R-V)
    const HIGHLIGHT_POSITIONS = new Set([4, 13, 14, 18, 19, 20, 21, 22]);

    // CMYK conversion
    function comboToCMYK(combo) {
      const toPercent = (val) => Math.round((val % 1000) / 10);
      return {
        c: toPercent(combo[0]),
        m: toPercent(combo[1]),
        y: toPercent(combo[2]),
        k: toPercent(combo[3])
      };
    }

    function cmykToRgb(c, m, y, k) {
      c /= 100; m /= 100; y /= 100; k /= 100;
      return {
        r: Math.round(255 * (1 - c) * (1 - k)),
        g: Math.round(255 * (1 - m) * (1 - k)),
        b: Math.round(255 * (1 - y) * (1 - k))
      };
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function getColor() {
      const cmyk = comboToCMYK(currentCombo);
      const rgb = cmykToRgb(cmyk.c, cmyk.m, cmyk.y, cmyk.k);
      return { cmyk, rgb, hex: rgbToHex(rgb.r, rgb.g, rgb.b) };
    }

    // INVERSE letter colors (swapped from before)
    function getLetterColor(symbol, isHighlighted) {
      if (symbol === '*') return '#c41e3a'; // Red for asterisk (was green)

      const idx = ALPHABET.indexOf(symbol);

      // Red: E, F, N (was green)
      if (['E', 'F', 'N'].includes(symbol)) return '#c41e3a';

      // Green: R-Z (was red)
      if (idx >= 17 && idx <= 25) return '#2e8b57';

      // Blue remains default but inverted intensity
      return '#1e4d8c';
    }

    // Generate base 3-row polyhedron grid
    function generateBasePolyhedron() {
      const triangles = [];
      for (let row = 0; row < BASE_ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          triangles.push({
            row,
            col,
            pointing: col % 2 === 0 ? 'up' : 'down',
            index: row * COLS + col
          });
        }
      }
      return triangles;
    }

    // Mirror operations
    function xMirror(triangles, maxRow) {
      return triangles.map(t => ({
        ...t,
        row: maxRow - t.row,
        index: (maxRow - t.row) * COLS + t.col
      }));
    }

    function yMirror(triangles, maxCol) {
      return triangles.map(t => ({
        ...t,
        col: maxCol - t.col,
        pointing: t.pointing === 'up' ? 'down' : 'up',
        index: t.row * COLS + (maxCol - t.col)
      }));
    }

    // Build full tessellation from base polyhedron
    function buildTessellation(variation) {
      const base = generateBasePolyhedron();

      // Step 1: X-mirror base to create 6-row polycolumn
      const xMirrored = xMirror(base, BASE_ROWS - 1);
      const polycolumn = [
        ...base.map(t => ({ ...t, section: 'top' })),
        ...xMirrored.map(t => ({ ...t, row: t.row + BASE_ROWS, section: 'bottom' }))
      ];

      // Step 2: Y-mirror to create pair
      const polycolumnWidth = COLS;
      const yMirroredColumn = polycolumn.map(t => ({
        ...t,
        col: t.col + polycolumnWidth + 1, // Offset for second column
        originalCol: t.col,
        yMirrored: true
      }));

      // Variation 0: Normal pair
      // Variation 1: X-mirrored pair (inverted shape)
      let columns;
      if (variation === 0) {
        columns = [...polycolumn, ...yMirroredColumn];
      } else {
        // X-mirror both columns for inverted shape
        const invertedCol1 = polycolumn.map(t => ({
          ...t,
          row: 5 - t.row, // Flip vertically within 6 rows
          section: t.section === 'top' ? 'bottom' : 'top'
        }));
        const invertedCol2 = yMirroredColumn.map(t => ({
          ...t,
          row: 5 - t.row,
          section: t.section === 'top' ? 'bottom' : 'top'
        }));
        columns = [...invertedCol1, ...invertedCol2];
      }

      return columns;
    }

    // Get triangle path
    function getTrianglePath(x, y, pointing) {
      const halfWidth = TRI_SIZE / 2;
      if (pointing === 'up') {
        return `M ${x} ${y + TRI_HEIGHT} L ${x + halfWidth} ${y} L ${x + TRI_SIZE} ${y + TRI_HEIGHT} Z`;
      } else {
        return `M ${x} ${y} L ${x + TRI_SIZE} ${y} L ${x + halfWidth} ${y + TRI_HEIGHT} Z`;
      }
    }

    // Render tessellation
    function render() {
      const svg = document.getElementById('tessellationSvg');
      const config = CONFIGS[CONFIG_KEYS[currentConfigIndex]];
      const color = getColor();

      // Update UI
      document.getElementById('configName').textContent = config.name;
      document.getElementById('variationInfo').textContent = `${currentVariation + 1}/2`;
      document.getElementById('frameInfo').textContent = `${currentFrame + 1}/6`;
      document.getElementById('cmykInfo').textContent =
        `${color.cmyk.c}/${color.cmyk.m}/${color.cmyk.y}/${color.cmyk.k}`;
      document.getElementById('colorSwatch').style.backgroundColor = color.hex;

      // Build tessellation
      const tessellation = buildTessellation(currentVariation);

      // Calculate dimensions
      const totalCols = COLS * 2 + 1; // Two polycolumns side by side
      const totalRows = 6; // 6-row polycolumns
      const svgWidth = totalCols * (TRI_SIZE / 2) + TRI_SIZE;
      const svgHeight = totalRows * TRI_HEIGHT + TRI_HEIGHT;

      svg.setAttribute('width', svgWidth);
      svg.setAttribute('height', svgHeight);
      svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

      // Center offset
      const offsetX = TRI_SIZE / 2;
      const offsetY = TRI_HEIGHT / 2;

      let svgContent = `<rect width="100%" height="100%" fill="#f8f8f4"/>`;

      // Draw all triangles
      tessellation.forEach(tri => {
        const x = offsetX + tri.col * (TRI_SIZE / 2);
        const y = offsetY + tri.row * TRI_HEIGHT;

        // Get symbol based on position in original 27-position grid
        const baseIndex = (tri.row % BASE_ROWS) * COLS + (tri.originalCol !== undefined ? tri.originalCol : tri.col) % COLS;
        const symbol = config.getSymbol(baseIndex % 27);

        const isHighlighted = HIGHLIGHT_POSITIONS.has(baseIndex % 27);
        const letterColor = getLetterColor(symbol, isHighlighted);

        // Triangle fill
        const fill = isHighlighted ? color.hex : '#f8f8f4';
        const fillOpacity = isHighlighted ? 0.6 : 1;

        const path = getTrianglePath(x, y, tri.pointing);
        svgContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#333" stroke-width="1.5"/>`;

        // Letter
        const textX = x + TRI_SIZE / 2;
        const textY = y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);
        svgContent += `<text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                             font-family="Arial" font-size="11" font-weight="bold" fill="${letterColor}">${symbol}</text>`;
      });

      svg.innerHTML = svgContent;
    }

    // Animation
    function animate() {
      if (!isPlaying) return;

      currentFrame++;
      if (currentFrame >= 6) {
        currentFrame = 0;
        currentVariation++;
        if (currentVariation >= 2) {
          currentVariation = 0;
          currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length;
        }
      }

      render();
      animationTimer = setTimeout(animate, 500);
    }

    // Event handlers
    document.getElementById('playPause').addEventListener('click', () => {
      isPlaying = !isPlaying;
      document.getElementById('playPause').textContent = isPlaying ? '⏸' : '▶';
      if (isPlaying) animate();
      else if (animationTimer) clearTimeout(animationTimer);
    });

    document.getElementById('prevVar').addEventListener('click', () => {
      const total = CONFIG_KEYS.length * 2;
      let current = currentConfigIndex * 2 + currentVariation;
      current = (current - 1 + total) % total;
      currentConfigIndex = Math.floor(current / 2);
      currentVariation = current % 2;
      currentFrame = 0;
      render();
    });

    document.getElementById('nextVar').addEventListener('click', () => {
      const total = CONFIG_KEYS.length * 2;
      let current = currentConfigIndex * 2 + currentVariation;
      current = (current + 1) % total;
      currentConfigIndex = Math.floor(current / 2);
      currentVariation = current % 2;
      currentFrame = 0;
      render();
    });

    document.getElementById('phraseSelect').addEventListener('change', (e) => {
      currentCombo = e.target.value.split('/').map(Number);
      render();
    });

    document.getElementById('exportSvg').addEventListener('click', () => {
      const svg = document.getElementById('tessellationSvg');
      const svgData = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `gematria-${CONFIG_KEYS[currentConfigIndex]}-v${currentVariation + 1}.svg`;
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById('exportGif').addEventListener('click', () => {
      alert('GIF export: Record all 12 variations cycling through 6 frames each.');
    });

    document.getElementById('exportWebm').addEventListener('click', () => {
      alert('WebM export: Use screen recording to capture the animation.');
    });

    // Initialize
    render();
    animate();
  </script>
</body>
</html>
