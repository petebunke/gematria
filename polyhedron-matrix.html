<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Gematria Polyhedron Tessellation</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f0;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    #backgroundSvg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.3;
    }

    .controls-overlay {
      background: rgba(255,255,255,0.95);
      border-bottom: 2px solid #333;
      padding: 8px 16px;
      width: 100%;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .control-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
    }

    select, button, input {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      color: #333;
      padding: 4px 6px;
      font-size: 11px;
      outline: none;
    }
    select:focus, input:focus {
      border-color: #6b5b95;
    }

    input[type="number"] {
      width: 60px;
    }

    button {
      background: #6b5b95;
      border-color: #6b5b95;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #5a4a84; }
    button.secondary {
      background: #fff;
      color: #6b5b95;
      border-color: #6b5b95;
    }

    .info-display {
      font-family: monospace;
      font-size: 10px;
      background: #f0f0e8;
      padding: 2px 5px;
      border-radius: 4px;
    }

    .color-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid #333;
    }

    .tessellation-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
      padding: 20px;
      cursor: grab;
    }

    #tessellationSvg {
      width: 800px;
      height: 600px;
      touch-action: none;
      border: 2px solid #333;
      background: #f8f8f4;
    }
  </style>
</head>
<body>
  <svg id="backgroundSvg" preserveAspectRatio="xMidYMid slice"></svg>
  <div class="controls-overlay">
    <div class="control-group">
      <span class="control-label">Phrase</span>
      <select id="phraseSelect">
        <option value="decide cabbagehead|111/666/111/333">decide cabbagehead (111/666/111/333)</option>
        <option value="a hall shall lid|222/666/111/55">a hall shall lid (222/666/111/55)</option>
        <option value="olio khaldian|222/666/111/99">olio khaldian (222/666/111/99)</option>
        <option value="act shah high|333/666/111/99">act shah high (333/666/111/99)</option>
        <option value="cad steadies dice|333/666/111/111">cad steadies dice (333/666/111/111)</option>
        <option value="xl male fall|444/666/111/99">xl male fall (444/666/111/99)</option>
        <option value="khan calm lax k|444/666/111/99">khan calm lax k (444/666/111/99)</option>
        <option value="stunner|555/666/111/111">stunner (555/666/111/111)</option>
        <option value="lute rot quest|555/666/111/111">lute rot quest (555/666/111/111)</option>
        <option value="qrs teukten runs rue most|555/666/111/111">qrs teukten runs... (555/666/111/111)</option>
        <option value="highland yoga|555/666/111/99">highland yoga (555/666/111/99)</option>
        <option value="uganda annual|555/666/111/99">uganda annual (555/666/111/99)</option>
        <option value="xbox add salad|777/666/111/99">xbox add salad (777/666/111/99)</option>
        <option value="xp ix hoo|777/666/111/111">xp ix hoo (777/666/111/111)</option>
        <option value="rug raz had a ea|888/666/111/99">rug raz had a ea (888/666/111/99)</option>
        <option value="baruch hazard|888/666/111/99">baruch hazard (888/666/111/99)</option>
        <option value="juice blade fief gf|888/666/111/111">juice blade fief gf (888/666/111/111)</option>
        <option value="black bull vala|999/666/111/99">black bull vala (999/666/111/99)</option>
        <option value="hiawatha hole|1111/666/111/99">hiawatha hole (1111/666/111/99)</option>
        <option value="flog hiawatha|1111/666/111/99">flog hiawatha (1111/666/111/99)</option>
        <option value="hiawatha golf|1111/666/111/99">hiawatha golf (1111/666/111/99)</option>
        <option value="hang sandwich|1111/666/111/99">hang sandwich (1111/666/111/99)</option>
        <option value="aye ayahuasca|1111/666/111/99">aye ayahuasca (1111/666/111/99)</option>
        <option value="ayahuasca yea|1111/666/111/99">ayahuasca yea (1111/666/111/99)</option>
        <option value="a gang shag win|1111/666/111/99">a gang shag win (1111/666/111/99)</option>
        <option value="hold at hawaii|1111/666/111/99">hold at hawaii (1111/666/111/99)</option>
        <option value="a swag hanging|1111/666/111/99">a swag hanging (1111/666/111/99)</option>
        <option value="lash which cap|1111/666/111/99">lash which cap (1111/666/111/99)</option>
        <option value="chaps haw lich|1111/666/111/99">chaps haw lich (1111/666/111/99)</option>
        <option value="how dragading|1111/666/111/99">how dragading (1111/666/111/99)</option>
        <option value="added add efface decided bidi|1111/666/111/111">added add efface... (1111/666/111/111)</option>
        <option value="chow hc flat hd|1111/666/111/111">chow hc flat hd (1111/666/111/111)</option>
        <option value="which paschal|1111/666/111/111">which paschal (1111/666/111/111)</option>
        <option value="russeting poor bamoth buggery sculks aeons details nonsolubly fin psychology omoideum postmarital|5555/6666/1111/111">russeting poor bamoth... (5555/6666/1111/111)</option>
        <option value="featurish constitution molybdosis gownsman models alkanal chaparajos hl inflation bidder foresails massagist|5555/6666/1111/111">featurish constitution... (5555/6666/1111/111)</option>
        <option value="bloodless foot sections metroxylon subtle fluster thermostats propiolic erotesis dans rahanwin|5555/6666/1111/111">bloodless foot sections... (5555/6666/1111/111)</option>
        <option value="churchgoing pancratiast lushest crowns galloon carper blanquillos altered nonvitriolic eudora baalisms drang|5555/6666/1111/1111">churchgoing pancratiast... (5555/6666/1111/1111)</option>
        <option value="hesperornis jurassic sensitizes polyoecy stanford silting monkeyishly physiology confidantes|6666/6666/1111/1111">hesperornis jurassic... (6666/6666/1111/1111)</option>
        <option value="youthfullity denaturize consumption overgrossly kaphs autolysate smarting medal praesphenoid|6666/6666/1111/1111">youthfullity denaturize... (6666/6666/1111/1111)</option>
        <option value="quaestiones makers interactions disavowedly errors spermatocyst addressed apteryxes outcrows|7777/6666/1111/1111">quaestiones makers... (7777/6666/1111/1111)</option>
        <option value="outsearch deposit sanely erasions tarworks prefers adjustments shopping elvis power snubbishly|7777/6666/1111/1111">outsearch deposit... (7777/6666/1111/1111)</option>
        <option value="pudsy caldera burns jiveass ponderous stereotyper isidium longest swotted inundatory doddypoll|7777/6666/1111/1111">pudsy caldera burns... (7777/6666/1111/1111)</option>
        <option value="irreverences outborn throughout beanballs diary lignosity souush swoony obvious benamed exist|7777/6666/1111/1111">irreverences outborn... (7777/6666/1111/1111)</option>
        <option value="sexoticalness eucre fumously harley aivers yokewood queal nitrosate yusdrum execrate honourless|7777/6666/1111/1111">sexoticalness eucre... (7777/6666/1111/1111)</option>
        <option value="barway filched firlot sovereignize helicteres oversorrow state priggishness civie soldiers dansker glaciable|7777/6666/1111/111">barway filched firlot... (7777/6666/1111/111)</option>
        <option value="therapeutic|8888/6666/1111/1111">therapeutic (8888/6666/1111/1111)</option>
        <option value="vessel therapeutic chrysazol spot travelling solutize swagman citizenries symptosis fatwa boat|8888/6666/1111/1111">vessel therapeutic... (8888/6666/1111/1111)</option>
        <option value="www moneyflower receptary creature attention juked econometrist tight cany yertchuk simaba fellowman|9999/6666/1111/111">www moneyflower... (9999/6666/1111/111)</option>
      </select>
    </div>

    <div class="control-group">
      <span class="control-label">Mode</span>
      <select id="displayMode">
        <option value="single" selected>Single (3 rows)</option>
        <option value="dual">Dual (6 rows)</option>
        <option value="quad">Quad (2 columns)</option>
        <option value="octa">Octa (8 forms)</option>
        <option value="square">Square (16 forms)</option>
        <option value="rectangle">Rectangle (64 forms)</option>
        <option value="square256">Square (256 forms)</option>
      </select>
    </div>

    <div class="control-group">
      <span class="control-label">Config</span>
      <span class="info-display" id="configName">a-*-z</span>
    </div>

    <div class="control-group">
      <span class="control-label">Var</span>
      <span class="info-display" id="variationName" style="width: 52px; text-align: center;">Normal</span>
    </div>

    <div class="control-group">
      <span class="control-label">Speed</span>
      <input type="number" id="frameSpeed" value="666" min="1" max="999" step="1">
      <span class="control-label">ms</span>
    </div>

    <div class="control-group">
      <button id="playPause" style="width: 32px;">⏸</button>
      <button id="prevVar" class="secondary">◀</button>
      <button id="nextVar" class="secondary">▶</button>
      <button id="loopBtn" class="secondary">LOOP</button>
    </div>

    <div class="control-group">
      <span class="control-label">Auto</span>
      <button id="oscToggle" class="secondary">OFF</button>
    </div>

    <div class="control-group">
      <span class="control-label">Zoom</span>
      <span class="info-display" id="zoomLevel">100%</span>
    </div>

    <div class="control-group">
      <button id="exportGif" class="secondary">GIF</button>
      <button id="exportHtml" class="secondary">HTML</button>
    </div>
  </div>

  <div class="tessellation-container" id="container">
    <svg id="tessellationSvg" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <script>
    // Constants
    const TRI_SIZE = 32;
    const TRI_HEIGHT = TRI_SIZE * Math.sqrt(3) / 2;
    const COLS = 9;      // Triangles per row in base polyhedron
    const BASE_ROWS = 3; // Base polyhedron rows

    // Alphabet
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // Row colors for polyhedron (by row position)
    const ROW_COLORS = {
      0: '#c41e3a', // Row 1: Red
      1: '#2e8b57', // Row 2: Green
      2: '#1e4d8c'  // Row 3: Blue
    };

    // 6 configurations
    const CONFIGS = {
      'a-*-z': {
        name: 'a-*-z',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[pos];
          if (pos === 13) return '*';
          return ALPHABET[pos - 1];
        }
      },
      '*-a-z': {
        name: '*-a-z',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[pos - 1];
        }
      },
      'a-z-*': {
        name: 'a-z-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[pos];
        }
      },
      'z-*-a': {
        name: 'z-*-a',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[25 - pos];
          if (pos === 13) return '*';
          return ALPHABET[25 - (pos - 1)];
        }
      },
      '*-z-a': {
        name: '*-z-a',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[26 - pos];
        }
      },
      'z-a-*': {
        name: 'z-a-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[25 - pos];
        }
      }
    };

    const CONFIG_KEYS = Object.keys(CONFIGS);

    // State
    let currentPhrase = 'decide cabbagehead';
    let currentCombo = [111, 666, 111, 333];
    let currentConfigIndex = 0;
    let currentVariation = 0; // 0 = normal, 1 = inverted
    let isPlaying = true;
    let animationTimer = null;
    let frameSpeed = 666;
    let displayMode = 'single'; // 'single', 'dual', 'quad', 'octa', 'square', or 'rectangle'
    let configDirection = 1; // 1 = forward, -1 = reverse
    let loopMode = 0; // 0 = both (forward then backward), 1 = forward only, 2 = backward only

    // Self-oscillator (swing) state
    let oscActive = false;

    // Zoom and pan state
    let scale = 0.5;
    let panX = 0;
    let panY = 0;
    let initialDistance = 0;
    let initialScale = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartPanX = 0;
    let dragStartPanY = 0;

    // Check if a letter is in the phrase
    function isLetterInPhrase(symbol, letterData) {
      return symbol !== '*' && (letterData.freq[symbol] || 0) > 0;
    }

    // Calculate letter frequency in phrase
    function getLetterFrequency(phrase) {
      const freq = {};
      const cleanPhrase = phrase.toUpperCase().replace(/[^A-Z]/g, '');

      for (const char of cleanPhrase) {
        freq[char] = (freq[char] || 0) + 1;
      }

      const maxFreq = Math.max(...Object.values(freq), 1);
      return { freq, maxFreq, totalLetters: cleanPhrase.length };
    }

    // Get opacity for a letter based on frequency
    function getLetterOpacity(symbol, letterData) {
      if (symbol === '*') {
        return 0.15;
      }

      const { freq, maxFreq } = letterData;
      const count = freq[symbol] || 0;

      if (count === 0) {
        return 0.15;
      }

      const baseOpacity = 0.3;
      const normalized = count / maxFreq;
      return baseOpacity + normalized * (1 - baseOpacity);
    }

    // Get letter color by ROW POSITION in polyhedron
    function getLetterColor(polyhedronRow) {
      return ROW_COLORS[polyhedronRow % 3];
    }

    // CMYK conversion
    function comboToCMYK(combo) {
      const toPercent = (val) => Math.round((val % 1000) / 10);
      return {
        c: toPercent(combo[0]),
        m: toPercent(combo[1]),
        y: toPercent(combo[2]),
        k: toPercent(combo[3])
      };
    }

    function cmykToRgb(c, m, y, k) {
      c /= 100; m /= 100; y /= 100; k /= 100;
      return {
        r: Math.round(255 * (1 - c) * (1 - k)),
        g: Math.round(255 * (1 - m) * (1 - k)),
        b: Math.round(255 * (1 - y) * (1 - k))
      };
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function getColor() {
      const cmyk = comboToCMYK(currentCombo);
      const rgb = cmykToRgb(cmyk.c, cmyk.m, cmyk.y, cmyk.k);
      return { cmyk, rgb, hex: rgbToHex(rgb.r, rgb.g, rgb.b) };
    }

    // Generate base 3-row polyhedron triangles
    function generateBasePolyhedron() {
      const triangles = [];
      for (let row = 0; row < BASE_ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          triangles.push({
            row,
            col,
            pointing: col % 2 === 0 ? 'up' : 'down',
            index: row * COLS + col,
            polyhedronRow: row
          });
        }
      }
      return triangles;
    }

    // Build dual mode: single column polyhedron (6 rows)
    // Top 3 rows: original, Bottom 3 rows: X-mirrored (reflected vertically)
    // Rows 0, 2, 4 are X-flipped (pointing reversed) for honeycomb pattern
    function buildDualStacked() {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      // Rows that need X-flip (1st, 3rd, 5th = 0, 2, 4)
      const xFlipRows = [0, 2, 4];

      // Top half: original (rows 0, 1, 2)
      base.forEach(t => {
        const x = t.col * (TRI_SIZE / 2);
        const y = t.row * TRI_HEIGHT;
        const finalRow = t.row;

        // X-flip for rows 0, 2, 4
        let pointing = t.pointing;
        if (xFlipRows.includes(finalRow)) {
          pointing = pointing === 'up' ? 'down' : 'up';
        }

        allTriangles.push({
          ...t,
          pointing,
          x,
          y,
          yMirror: false
        });
      });

      // Bottom half: X-mirrored (rows 2, 1, 0 placed at rows 3, 4, 5)
      // Same letters, reversed row order, pointing flipped from source row
      base.forEach(t => {
        const mirroredRow = BASE_ROWS - 1 - t.row; // 2->0, 1->1, 0->2
        const x = t.col * (TRI_SIZE / 2);
        const finalRow = BASE_ROWS + mirroredRow;
        const y = finalRow * TRI_HEIGHT;

        // X-flip for rows 0, 2, 4
        let pointing = t.pointing;
        if (xFlipRows.includes(finalRow)) {
          pointing = pointing === 'up' ? 'down' : 'up';
        }

        allTriangles.push({
          ...t,
          pointing,
          polyhedronRow: BASE_ROWS - 1 - t.polyhedronRow,
          x,
          y,
          yMirror: false
        });
      });

      return allTriangles;
    }

    // Build single mode: just one 3-row polyhedron, X-flipped
    // Rows 0, 2 are X-flipped for honeycomb, then whole thing X-flipped
    function buildSingle() {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      // Rows that need X-flip (1st, 3rd = 0, 2)
      const xFlipRows = [0, 2];

      base.forEach(t => {
        const x = t.col * (TRI_SIZE / 2);
        const y = t.row * TRI_HEIGHT;

        // X-flip for rows 0, 2, then flip entire form
        let pointing = t.pointing;
        if (xFlipRows.includes(t.row)) {
          pointing = pointing === 'up' ? 'down' : 'up';
        }
        // X-flip the whole form
        pointing = pointing === 'up' ? 'down' : 'up';

        allTriangles.push({
          ...t,
          pointing,
          x,
          y,
          yMirror: false
        });
      });

      return allTriangles;
    }

    // Build quad mode: two columns of 6-row polyhedrons
    // Left column: Y-mirrored (horizontally flipped letters)
    // Right column: Original orientation
    // Each column has: top 3 rows original, bottom 3 rows X-mirrored
    // Rows 0, 2, 4 (1st, 3rd, 5th) are X-flipped (pointing reversed)
    // variation 0 = Normal: [original on top, X-mirror below]
    // variation 1 = Inverted: [X-mirror on top, original below]
    function buildQuadMirrored(variation) {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      // Width = (COLS-1) half-widths for spacing + full triangle width
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;

      // Rows that need X-flip (1st, 3rd, 5th = 0, 2, 4)
      const xFlipRows = [0, 2, 4];

      // Two columns: left (Y-mirrored) and right (original)
      const columns = [
        { colIndex: 0, yMirror: true },   // Left: Y-mirrored
        { colIndex: 1, yMirror: false }   // Right: Original
      ];

      columns.forEach(({ colIndex, yMirror }) => {
        // Top half (rows 0-2)
        base.forEach(t => {
          let col = t.col;
          let pointing = t.pointing;
          let row, polyRow;

          if (variation === 0) {
            // Normal: original on top
            row = t.row;
            polyRow = t.polyhedronRow;
          } else {
            // Inverted: X-mirrored on top (rows 2,1,0)
            row = BASE_ROWS - 1 - t.row;
            polyRow = BASE_ROWS - 1 - t.polyhedronRow;
          }

          if (yMirror) {
            col = COLS - 1 - col;
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          // X-flip for rows 0, 2, 4
          if (xFlipRows.includes(row)) {
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          const x = colIndex * polyWidth + col * (TRI_SIZE / 2);
          const y = row * TRI_HEIGHT;

          allTriangles.push({
            ...t,
            col,
            pointing,
            polyhedronRow: polyRow,
            x,
            y,
            yMirror,
            section: 'top'
          });
        });

        // Bottom half (rows 3-5): X-mirrored from top
        base.forEach(t => {
          let col = t.col;
          let pointing = t.pointing;
          let row, polyRow;

          if (variation === 0) {
            // Normal: X-mirrored on bottom (rows 2,1,0 at positions 3,4,5)
            const mirroredRow = BASE_ROWS - 1 - t.row;
            row = BASE_ROWS + mirroredRow;
            polyRow = BASE_ROWS - 1 - t.polyhedronRow;
          } else {
            // Inverted: original on bottom (rows 0,1,2 at positions 3,4,5)
            row = BASE_ROWS + t.row;
            polyRow = t.polyhedronRow;
          }

          if (yMirror) {
            col = COLS - 1 - col;
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          // X-flip for rows 0, 2, 4
          if (xFlipRows.includes(row)) {
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          const x = colIndex * polyWidth + col * (TRI_SIZE / 2);
          const y = row * TRI_HEIGHT;

          allTriangles.push({
            ...t,
            col,
            pointing,
            polyhedronRow: polyRow,
            x,
            y,
            yMirror,
            section: 'bottom'
          });
        });
      });

      return allTriangles;
    }

    // Build octa mode: 2x2 grid of 4 quad forms with gaps
    // Arranged so same shapes touch same shapes
    // Top-left: Original quad, Top-right: Y-mirrored clone
    // Bottom-left: X-mirrored clone, Bottom-right: X&Y-mirrored clone
    // variation 0 = Normal, variation 1 = Inverted
    function buildOcta(variation) {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      const quadWidth = polyWidth * 2;
      const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      const xFlipRows = [0, 2, 4];
      const GAP = 8; // Gap between quads

      // 4 quadrants arranged so same shapes touch
      // Top row: Original | Y-mirrored (touching at Y-mirror edge)
      // Bottom row: X-mirrored versions (touching top row at X-mirror edge)
      const quadrants = [
        { qRow: 0, qCol: 0, xFlipAll: false, yFlipAll: false }, // Top-left: original
        { qRow: 0, qCol: 1, xFlipAll: false, yFlipAll: true },  // Top-right: Y-mirrored
        { qRow: 1, qCol: 0, xFlipAll: true, yFlipAll: false },  // Bottom-left: X-mirrored
        { qRow: 1, qCol: 1, xFlipAll: true, yFlipAll: true }    // Bottom-right: X&Y-mirrored
      ];

      quadrants.forEach(({ qRow, qCol, xFlipAll, yFlipAll }) => {
        const quadXOffset = qCol * quadWidth;  // No gap between columns in same row
        const quadYOffset = qRow * (quadHeight + GAP);  // Gap only between rows

        // Columns within this quadrant
        // For bottom row (xFlipAll), swap column order so same shapes touch
        let columns;
        if (xFlipAll) {
          // Bottom row: swap column order
          columns = yFlipAll
            ? [
                { colIndex: 0, yMirror: true },
                { colIndex: 1, yMirror: false }
              ]
            : [
                { colIndex: 0, yMirror: false },
                { colIndex: 1, yMirror: true }
              ];
        } else {
          // Top row: normal order
          columns = yFlipAll
            ? [
                { colIndex: 0, yMirror: false },
                { colIndex: 1, yMirror: true }
              ]
            : [
                { colIndex: 0, yMirror: true },
                { colIndex: 1, yMirror: false }
              ];
        }

        columns.forEach(({ colIndex, yMirror }) => {
          // Top half (rows 0-2)
          base.forEach(t => {
            let col = t.col;
            let pointing = t.pointing;
            let row, polyRow;

            if (variation === 0) {
              row = t.row;
              polyRow = t.polyhedronRow;
            } else {
              row = BASE_ROWS - 1 - t.row;
              polyRow = BASE_ROWS - 1 - t.polyhedronRow;
            }

            if (yMirror) {
              col = COLS - 1 - col;
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            if (xFlipRows.includes(row)) {
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            if (xFlipAll) {
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            const x = quadXOffset + colIndex * polyWidth + col * (TRI_SIZE / 2);
            const y = quadYOffset + row * TRI_HEIGHT;

            allTriangles.push({
              ...t,
              col,
              pointing,
              polyhedronRow: polyRow,
              x,
              y,
              yMirror,
              section: 'top'
            });
          });

          // Bottom half (rows 3-5)
          base.forEach(t => {
            let col = t.col;
            let pointing = t.pointing;
            let row, polyRow;

            if (variation === 0) {
              const mirroredRow = BASE_ROWS - 1 - t.row;
              row = BASE_ROWS + mirroredRow;
              polyRow = BASE_ROWS - 1 - t.polyhedronRow;
            } else {
              row = BASE_ROWS + t.row;
              polyRow = t.polyhedronRow;
            }

            if (yMirror) {
              col = COLS - 1 - col;
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            if (xFlipRows.includes(row)) {
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            if (xFlipAll) {
              pointing = pointing === 'up' ? 'down' : 'up';
            }

            const x = quadXOffset + colIndex * polyWidth + col * (TRI_SIZE / 2);
            const y = quadYOffset + row * TRI_HEIGHT;

            allTriangles.push({
              ...t,
              col,
              pointing,
              polyhedronRow: polyRow,
              x,
              y,
              yMirror,
              section: 'bottom'
            });
          });
        });
      });

      return allTriangles;
    }

    // Build square mode: 2x4 grid of 8 quads (16 poly forms total)
    // Top half: X-mirrored octa layout (4 quads in 2x2, with globalXFlip applied)
    // Bottom half: Original octa layout (4 quads in 2x2)
    // variation 0 = Normal, variation 1 = Inverted
    function buildSquare(variation) {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      const quadWidth = polyWidth * 2;
      const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      const xFlipRows = [0, 2, 4];
      const GAP = 8; // Gap between rows

      // 8 quadrants: 4 for top (x-mirrored) octa, 4 for bottom (original) octa
      // Top half: X-mirrored octa (all 8 forms get additional X-flip)
      // Bottom half: Original octa
      const octaHalves = [
        { halfRow: 0, globalXFlip: true },  // Top: x-mirrored octa
        { halfRow: 1, globalXFlip: false }  // Bottom: original octa
      ];

      // Octa quadrants within each half
      const octaQuadrants = [
        { qRow: 0, qCol: 0, xFlipAll: false, yFlipAll: false }, // Top-left: original
        { qRow: 0, qCol: 1, xFlipAll: false, yFlipAll: true },  // Top-right: Y-mirrored
        { qRow: 1, qCol: 0, xFlipAll: true, yFlipAll: false },  // Bottom-left: X-mirrored
        { qRow: 1, qCol: 1, xFlipAll: true, yFlipAll: true }    // Bottom-right: X&Y-mirrored
      ];

      const octaHeight = quadHeight * 2 + GAP;

      octaHalves.forEach(({ halfRow, globalXFlip }) => {
        const halfYOffset = halfRow * (octaHeight + GAP);

        octaQuadrants.forEach(({ qRow, qCol, xFlipAll, yFlipAll }) => {
          const quadXOffset = qCol * quadWidth;  // No gap between columns
          const quadYOffset = halfYOffset + qRow * (quadHeight + GAP);

          // Combined X-flip: octa's xFlipAll XOR global X-flip for this half
          const combinedXFlip = xFlipAll !== globalXFlip;

          // For bottom row (combinedXFlip), swap column order so same shapes touch
          let columns;
          if (combinedXFlip) {
            // Bottom row: swap column order
            columns = yFlipAll
              ? [
                  { colIndex: 0, yMirror: true },
                  { colIndex: 1, yMirror: false }
                ]
              : [
                  { colIndex: 0, yMirror: false },
                  { colIndex: 1, yMirror: true }
                ];
          } else {
            // Top row: normal order
            columns = yFlipAll
              ? [
                  { colIndex: 0, yMirror: false },
                  { colIndex: 1, yMirror: true }
                ]
              : [
                  { colIndex: 0, yMirror: true },
                  { colIndex: 1, yMirror: false }
                ];
          }

          columns.forEach(({ colIndex, yMirror }) => {
            // Top half (rows 0-2)
            base.forEach(t => {
              let col = t.col;
              let pointing = t.pointing;
              let row, polyRow;

              if (variation === 0) {
                row = t.row;
                polyRow = t.polyhedronRow;
              } else {
                row = BASE_ROWS - 1 - t.row;
                polyRow = BASE_ROWS - 1 - t.polyhedronRow;
              }

              if (yMirror) {
                col = COLS - 1 - col;
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (xFlipRows.includes(row)) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (xFlipAll) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (globalXFlip) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              const x = quadXOffset + colIndex * polyWidth + col * (TRI_SIZE / 2);
              const y = quadYOffset + row * TRI_HEIGHT;

              allTriangles.push({
                ...t,
                col,
                pointing,
                polyhedronRow: polyRow,
                x,
                y,
                yMirror,
                section: 'top'
              });
            });

            // Bottom half (rows 3-5)
            base.forEach(t => {
              let col = t.col;
              let pointing = t.pointing;
              let row, polyRow;

              if (variation === 0) {
                const mirroredRow = BASE_ROWS - 1 - t.row;
                row = BASE_ROWS + mirroredRow;
                polyRow = BASE_ROWS - 1 - t.polyhedronRow;
              } else {
                row = BASE_ROWS + t.row;
                polyRow = t.polyhedronRow;
              }

              if (yMirror) {
                col = COLS - 1 - col;
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (xFlipRows.includes(row)) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (xFlipAll) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              if (globalXFlip) {
                pointing = pointing === 'up' ? 'down' : 'up';
              }

              const x = quadXOffset + colIndex * polyWidth + col * (TRI_SIZE / 2);
              const y = quadYOffset + row * TRI_HEIGHT;

              allTriangles.push({
                ...t,
                col,
                pointing,
                polyhedronRow: polyRow,
                x,
                y,
                yMirror,
                section: 'bottom'
              });
            });
          });
        });
      });

      return allTriangles;
    }

    // Build rectangle mode: 4 square grids side by side, alternating x-flip
    // Pattern: original > x-flipped > original > x-flipped
    // variation 0 = Normal, variation 1 = Inverted
    function buildRectangle(variation) {
      const allTriangles = [];
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      const GAP = 8;
      const squareWidth = polyWidth * 4;

      // Build 4 square grids with alternating x-flip
      for (let gridIndex = 0; gridIndex < 4; gridIndex++) {
        const squareTriangles = buildSquare(variation);
        const xOffset = gridIndex * (squareWidth + GAP);
        const shouldXFlip = gridIndex % 2 === 1; // Flip 2nd and 4th (indices 1 and 3)

        squareTriangles.forEach(tri => {
          let newPointing = tri.pointing;

          // X-flip: flip the pointing direction
          if (shouldXFlip) {
            newPointing = tri.pointing === 'up' ? 'down' : 'up';
          }

          allTriangles.push({
            ...tri,
            x: tri.x + xOffset,
            y: tri.y,
            pointing: newPointing,
            gridIndex: gridIndex
          });
        });
      }

      return allTriangles;
    }

    // Build square256 mode: 4 rows of rectangle patterns stacked vertically
    // Each row is x-mirrored relative to the one below it
    // Bottom row: original rectangle, then alternating x-flip going up
    // variation 0 = Normal, variation 1 = Inverted
    function buildSquare256(variation) {
      const allTriangles = [];
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      const GAP = 8;
      const squareWidth = polyWidth * 4;
      const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      const octaHeight = quadHeight * 2 + GAP;
      const squareHeight = octaHeight * 2 + GAP;
      const rectangleHeight = squareHeight;

      // Build 4 rows of rectangles with alternating x-flip
      // Row 3 (bottom): original, Row 2: x-flip, Row 1: original, Row 0 (top): x-flip
      for (let rowIndex = 0; rowIndex < 4; rowIndex++) {
        const rectangleTriangles = buildRectangle(variation);
        const yOffset = rowIndex * (rectangleHeight + GAP);
        // Rows 0 and 2 are x-flipped (top and 3rd from top)
        const shouldXFlip = rowIndex % 2 === 0;

        rectangleTriangles.forEach(tri => {
          let newPointing = tri.pointing;

          // X-flip: flip the pointing direction
          if (shouldXFlip) {
            newPointing = tri.pointing === 'up' ? 'down' : 'up';
          }

          allTriangles.push({
            ...tri,
            x: tri.x,
            y: tri.y + yOffset,
            pointing: newPointing,
            rowIndex: rowIndex
          });
        });
      }

      return allTriangles;
    }

    // Get triangle path
    function getTrianglePath(x, y, pointing) {
      const halfWidth = TRI_SIZE / 2;
      if (pointing === 'up') {
        return `M ${x} ${y + TRI_HEIGHT} L ${x + halfWidth} ${y} L ${x + TRI_SIZE} ${y + TRI_HEIGHT} Z`;
      } else {
        return `M ${x} ${y} L ${x + TRI_SIZE} ${y} L ${x + halfWidth} ${y + TRI_HEIGHT} Z`;
      }
    }

    // Render
    function render() {
      const svg = document.getElementById('tessellationSvg');
      const config = CONFIGS[CONFIG_KEYS[currentConfigIndex]];
      const color = getColor();
      const letterData = getLetterFrequency(currentPhrase);

      // Update UI
      document.getElementById('configName').textContent = config.name;

      // Variation name based on mode
      let varName = '-';
      if (displayMode === 'quad' || displayMode === 'octa' || displayMode === 'square' || displayMode === 'rectangle' || displayMode === 'square256') {
        varName = currentVariation === 0 ? 'Normal' : 'Inverted';
      }
      document.getElementById('variationName').textContent = varName;
      document.getElementById('zoomLevel').textContent = `${Math.round(scale * 100)}%`;

      // Build triangles based on mode
      let triangles;
      let totalWidth, totalHeight;

      // Width = (COLS-1) half-widths for spacing + full triangle width
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;

      if (displayMode === 'single') {
        triangles = buildSingle();
        totalWidth = polyWidth;
        totalHeight = BASE_ROWS * TRI_HEIGHT;
      } else if (displayMode === 'dual') {
        triangles = buildDualStacked();
        totalWidth = polyWidth;
        totalHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      } else if (displayMode === 'square256') {
        triangles = buildSquare256(currentVariation);
        const GAP = 8;
        const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
        const octaHeight = quadHeight * 2 + GAP;
        const squareWidth = polyWidth * 4;
        const squareHeight = octaHeight * 2 + GAP;
        const rectangleWidth = squareWidth * 4 + GAP * 3;
        const rectangleHeight = squareHeight;
        totalWidth = rectangleWidth;  // Same width as rectangle
        totalHeight = rectangleHeight * 4 + GAP * 3;  // 4 rows of rectangles
      } else if (displayMode === 'rectangle') {
        triangles = buildRectangle(currentVariation);
        const GAP = 8;
        const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
        const octaHeight = quadHeight * 2 + GAP;
        const squareWidth = polyWidth * 4;
        const squareHeight = octaHeight * 2 + GAP;
        totalWidth = squareWidth * 4 + GAP * 3;  // 4 squares side by side with gaps
        totalHeight = squareHeight;
      } else if (displayMode === 'square') {
        triangles = buildSquare(currentVariation);
        const GAP = 8;
        const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
        const octaHeight = quadHeight * 2 + GAP;
        totalWidth = polyWidth * 4;  // 2 columns of quads, no horizontal gap
        totalHeight = octaHeight * 2 + GAP;  // 2 octas stacked vertically
      } else if (displayMode === 'octa') {
        triangles = buildOcta(currentVariation);
        const GAP = 8;
        totalWidth = polyWidth * 4;  // 2x2 grid of quads, no horizontal gap
        totalHeight = BASE_ROWS * 4 * TRI_HEIGHT + GAP;  // Gap only between rows
      } else {
        // quad mode
        triangles = buildQuadMirrored(currentVariation);
        totalWidth = polyWidth * 2;
        totalHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      }

      // Apply zoom and pan via viewBox (SVG stays fixed size in container)
      const viewWidth = totalWidth / scale;
      const viewHeight = totalHeight / scale;
      const viewX = (totalWidth - viewWidth) / 2 + panX;
      const viewY = (totalHeight - viewHeight) / 2 + panY;

      svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);

      let svgContent = `<rect x="0" y="0" width="${totalWidth}" height="${totalHeight}" fill="#f8f8f4"/>`;

      // Draw all triangles
      triangles.forEach(tri => {
        const symbol = config.getSymbol(tri.index % 27);
        const letterOpacity = getLetterOpacity(symbol, letterData);
        const letterColor = getLetterColor(tri.polyhedronRow);

        const isInPhrase = isLetterInPhrase(symbol, letterData);
        const fill = isInPhrase ? color.hex : '#f8f8f4';
        const fillOpacity = isInPhrase ? letterOpacity : 0.08;

        const path = getTrianglePath(tri.x, tri.y, tri.pointing);
        svgContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#333" stroke-width="1"/>`;

        // Text positioning
        const textX = tri.x + TRI_SIZE / 2;
        const textY = tri.y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);

        // White text on colored bg, black text on white bg
        const textColor = isInPhrase ? '#ffffff' : '#000000';

        svgContent += `<text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                             font-family="Arial" font-size="9" font-weight="bold"
                             fill="${textColor}" fill-opacity="${letterOpacity}">${symbol}</text>`;
      });

      svg.innerHTML = svgContent;
    }

    // Get number of variations for current mode
    function getVariationCount() {
      if (displayMode === 'square256') return 2;
      if (displayMode === 'rectangle') return 2;
      if (displayMode === 'square') return 2;
      if (displayMode === 'octa') return 2;
      if (displayMode === 'quad') return 2;
      return 1; // single and dual have no variations
    }

    // Mode order for osc cycling
    const MODE_ORDER = ['single', 'dual', 'quad', 'octa', 'square', 'rectangle', 'square256'];
    let oscModeDirection = 1; // 1 = forward through modes, -1 = backward

    // Animation - cycles through variations and configs
    // loopMode 0: forward then backward, repeating
    // loopMode 1: forward only
    // loopMode 2: backward only
    function animate() {
      if (!isPlaying) return;

      const varCount = getVariationCount();
      let configChanged = false;
      let newConfigIndex = currentConfigIndex;

      if (varCount > 1) {
        // Cycle through variation first, then config
        currentVariation += configDirection;
        if (currentVariation >= varCount) {
          currentVariation = 0;
          newConfigIndex = currentConfigIndex + configDirection;
          configChanged = true;
        } else if (currentVariation < 0) {
          currentVariation = varCount - 1;
          newConfigIndex = currentConfigIndex + configDirection;
          configChanged = true;
        }
      } else {
        // Just cycle configs
        newConfigIndex = currentConfigIndex + configDirection;
        configChanged = true;
      }

      if (configChanged) {
        // Check if we've hit the boundary
        if (newConfigIndex >= CONFIG_KEYS.length || newConfigIndex < 0) {
          if (loopMode === 0) {
            // Reverse direction at boundaries
            const wasGoingBackward = configDirection === -1;
            configDirection *= -1;
            newConfigIndex = currentConfigIndex + configDirection;
            if (varCount > 1) {
              // Also reverse variation direction
              currentVariation += configDirection * 2; // Undo the overshoot and go the other way
              if (currentVariation < 0) currentVariation = varCount - 1;
              if (currentVariation >= varCount) currentVariation = 0;
            }

            // If osc is active and we just completed a backward pass (full cycle), advance mode
            if (oscActive && wasGoingBackward) {
              const currentModeIndex = MODE_ORDER.indexOf(displayMode);
              let nextModeIndex = currentModeIndex + oscModeDirection;

              // Reverse mode direction at boundaries
              if (nextModeIndex >= MODE_ORDER.length || nextModeIndex < 0) {
                oscModeDirection *= -1;
                nextModeIndex = currentModeIndex + oscModeDirection;
              }

              displayMode = MODE_ORDER[nextModeIndex];
              document.getElementById('displayMode').value = displayMode;
              currentVariation = 0;
              // Reset pan when mode changes during swing
              panX = 0;
              panY = 0;
              // Set appropriate zoom for rectangle and square256 modes
              if (displayMode === 'rectangle' || displayMode === 'square256') {
                scale = 0.75;
              }
            }
          } else {
            // Wrap around for locked loop modes
            newConfigIndex = (newConfigIndex + CONFIG_KEYS.length) % CONFIG_KEYS.length;
          }
        }
        currentConfigIndex = newConfigIndex;
      }

      render();

      // Use frameSpeed for all modes (including during Auto)
      animationTimer = setTimeout(animate, frameSpeed);
    }

    // Get total variation index
    function getTotalVariationIndex() {
      const varCount = getVariationCount();
      return currentConfigIndex * varCount + currentVariation;
    }

    // Set from total variation index
    function setFromTotalVariationIndex(idx) {
      const varCount = getVariationCount();
      const total = CONFIG_KEYS.length * varCount;
      idx = ((idx % total) + total) % total;
      currentConfigIndex = Math.floor(idx / varCount);
      currentVariation = idx % varCount;
    }

    // Pinch zoom handling
    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    const container = document.getElementById('container');

    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        initialDistance = getDistance(e.touches);
        initialScale = scale;
      }
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getDistance(e.touches);
        const newScale = initialScale * (currentDistance / initialDistance);
        // Rectangle mode: limit zoom out to 75%
        const minZoom = (displayMode === 'rectangle' || displayMode === 'square256') ? 0.75 : 0.25;
        scale = Math.max(minZoom, Math.min(5, newScale));
        render();
      }
    }, { passive: false });

    // Mouse wheel zoom
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      // Rectangle mode: limit zoom out to 75%
      const minZoom = (displayMode === 'rectangle' || displayMode === 'square256') ? 0.75 : 0.25;
      scale = Math.max(minZoom, Math.min(5, scale * zoomFactor));
      render();
    }, { passive: false });

    // Mouse drag for panning
    container.addEventListener('mousedown', (e) => {
      if (e.button === 0) { // Left mouse button
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartPanX = panX;
        dragStartPanY = panY;
        container.style.cursor = 'grabbing';
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const svg = document.getElementById('tessellationSvg');
        const rect = svg.getBoundingClientRect();
        // Convert pixel movement to viewBox units
        const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
        const scaleX = viewBox[2] / rect.width;
        const scaleY = viewBox[3] / rect.height;
        panX = dragStartPanX - (e.clientX - dragStartX) * scaleX;
        panY = dragStartPanY - (e.clientY - dragStartY) * scaleY;
        render();
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        container.style.cursor = '';
      }
    });

    // Touch drag for panning (single finger)
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        dragStartX = e.touches[0].clientX;
        dragStartY = e.touches[0].clientY;
        dragStartPanX = panX;
        dragStartPanY = panY;
      }
    }, { passive: true });

    container.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length === 1) {
        const svg = document.getElementById('tessellationSvg');
        const rect = svg.getBoundingClientRect();
        const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
        const scaleX = viewBox[2] / rect.width;
        const scaleY = viewBox[3] / rect.height;
        panX = dragStartPanX - (e.touches[0].clientX - dragStartX) * scaleX;
        panY = dragStartPanY - (e.touches[0].clientY - dragStartY) * scaleY;
        render();
      }
    }, { passive: true });

    container.addEventListener('touchend', () => {
      isDragging = false;
    }, { passive: true });

    // Event handlers
    document.getElementById('playPause').addEventListener('click', () => {
      isPlaying = !isPlaying;
      document.getElementById('playPause').textContent = isPlaying ? '⏸' : '▶';
      if (isPlaying) animate();
      else if (animationTimer) clearTimeout(animationTimer);
    });

    document.getElementById('prevVar').addEventListener('click', () => {
      const varCount = getVariationCount();
      if (varCount > 1) {
        setFromTotalVariationIndex(getTotalVariationIndex() - 1);
      } else {
        currentConfigIndex = (currentConfigIndex - 1 + CONFIG_KEYS.length) % CONFIG_KEYS.length;
      }
      render();
    });

    document.getElementById('nextVar').addEventListener('click', () => {
      const varCount = getVariationCount();
      if (varCount > 1) {
        setFromTotalVariationIndex(getTotalVariationIndex() + 1);
      } else {
        currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length;
      }
      render();
    });

    // Loop button - cycles through loop modes
    // 0 = both (forward then backward), 1 = forward only (LOOP 1), 2 = backward only (LOOP 2)
    document.getElementById('loopBtn').addEventListener('click', () => {
      loopMode = (loopMode + 1) % 3;
      const btn = document.getElementById('loopBtn');
      if (loopMode === 0) {
        btn.textContent = 'LOOP';
        btn.style.background = '';
        btn.style.color = '';
        // Reset to forward direction when returning to default
        configDirection = 1;
      } else if (loopMode === 1) {
        btn.textContent = 'LOOP 1';
        btn.style.background = '#6b5b95';
        btn.style.color = '#ffffff';
        configDirection = 1; // Forward only
      } else {
        btn.textContent = 'LOOP 2';
        btn.style.background = '#6b5b95';
        btn.style.color = '#ffffff';
        configDirection = -1; // Backward only
      }
    });

    // Convert aik bekar repdigit value to ms speed
    // 1111 → 1.111 ms (divide by 1000)
    // 333 → 33.3 ms (divide by 10)
    // 99 → 999 ms (multiply by 10 + last digit)
    function aikBekarToMs(value) {
      if (value <= 0) return 666;
      const numDigits = Math.floor(Math.log10(value)) + 1;

      if (numDigits >= 4) {
        // 4+ digits: divide by 10^(numDigits-1)
        return value / Math.pow(10, numDigits - 1);
      } else if (numDigits === 3) {
        // 3 digits: divide by 10
        return value / 10;
      } else if (numDigits === 2) {
        // 2 digits: multiply by 10 + last digit
        return value * 10 + (value % 10);
      } else {
        // 1 digit: multiply by 1111
        return value * 1111;
      }
    }

    function startOsc() {
      oscModeDirection = 1; // Reset mode direction
      oscActive = true;
      const btn = document.getElementById('oscToggle');
      btn.textContent = 'ON';
      btn.style.background = '#6b5b95';
      btn.style.color = '#ffffff';

      // Auto-play if paused
      if (!isPlaying) {
        isPlaying = true;
        document.getElementById('playPause').textContent = '⏸';
        animate();
      }

      // Frame speed comes from phrase selection via aik bekar formula
      // (already set when phrase was selected)
    }

    function stopOsc() {
      oscActive = false;
      const btn = document.getElementById('oscToggle');
      btn.textContent = 'OFF';
      btn.style.background = '';
      btn.style.color = '';
    }

    document.getElementById('oscToggle').addEventListener('click', () => {
      if (oscActive) {
        stopOsc();
      } else {
        startOsc();
      }
    });

    document.getElementById('phraseSelect').addEventListener('change', (e) => {
      const [phrase, combo] = e.target.value.split('|');
      currentPhrase = phrase;
      currentCombo = combo.split('/').map(Number);

      // Apply aik bekar formula to LAST combo value to set ms speed
      const aikBekarValue = currentCombo[currentCombo.length - 1];
      frameSpeed = aikBekarToMs(aikBekarValue);
      document.getElementById('frameSpeed').value = parseFloat(frameSpeed.toFixed(2));

      render();
      renderBackground();
      updateBackgroundSpeed();
    });

    document.getElementById('displayMode').addEventListener('change', (e) => {
      displayMode = e.target.value;
      currentVariation = 0;
      // Reset pan and set appropriate default zoom for large modes
      panX = 0;
      panY = 0;
      if (displayMode === 'rectangle' || displayMode === 'square256') {
        scale = 0.75; // More zoomed in for large modes
      }
      render();
      // Ensure animation continues after mode change (for oscillator)
      if (isPlaying && animationTimer) {
        clearTimeout(animationTimer);
        animationTimer = setTimeout(animate, frameSpeed);
      }
    });

    document.getElementById('frameSpeed').addEventListener('input', (e) => {
      frameSpeed = Math.min(999, Math.max(1, parseFloat(e.target.value) || 666));
      if (isPlaying && animationTimer) {
        clearTimeout(animationTimer);
        animationTimer = setTimeout(animate, frameSpeed);
      }
      updateBackgroundSpeed();
    });

    // Generate SVG content for a specific config and variation (off-screen, doesn't affect main view)
    function generateFrameSvg(configIdx, variation, width, height) {
      const config = CONFIGS[CONFIG_KEYS[configIdx]];
      const color = getColor();
      const letterData = getLetterFrequency(currentPhrase);

      // Build triangles based on mode
      let triangles;
      if (displayMode === 'single') {
        triangles = buildSingle();
      } else if (displayMode === 'dual') {
        triangles = buildDualStacked();
      } else if (displayMode === 'square256') {
        triangles = buildSquare256(variation);
      } else if (displayMode === 'rectangle') {
        triangles = buildRectangle(variation);
      } else if (displayMode === 'square') {
        triangles = buildSquare(variation);
      } else if (displayMode === 'octa') {
        triangles = buildOcta(variation);
      } else {
        triangles = buildQuadMirrored(variation);
      }

      let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">`;
      svgContent += `<rect x="0" y="0" width="${width}" height="${height}" fill="#f8f8f4"/>`;

      triangles.forEach(tri => {
        const symbol = config.getSymbol(tri.index % 27);
        const letterOpacity = getLetterOpacity(symbol, letterData);
        const isInPhrase = isLetterInPhrase(symbol, letterData);
        const fill = isInPhrase ? color.hex : '#f8f8f4';
        const fillOpacity = isInPhrase ? letterOpacity : 0.08;
        const path = getTrianglePath(tri.x, tri.y, tri.pointing);
        svgContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#333" stroke-width="1"/>`;
        const textX = tri.x + TRI_SIZE / 2;
        const textY = tri.y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);
        const textColor = isInPhrase ? '#ffffff' : '#000000';
        svgContent += `<text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle" font-family="Arial" font-size="9" font-weight="bold" fill="${textColor}" fill-opacity="${letterOpacity}">${symbol}</text>`;
      });

      svgContent += '</svg>';
      return svgContent;
    }

    // GIF Export - renders off-screen without affecting the main view
    document.getElementById('exportGif').addEventListener('click', async () => {
      const btn = document.getElementById('exportGif');
      const originalText = btn.textContent;
      btn.textContent = '...';
      btn.disabled = true;

      try {
        const varCount = getVariationCount();
        const totalFrames = CONFIG_KEYS.length * varCount;

        // Calculate actual content dimensions
        const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
        let width, height;
        const GAP = 8;
        const quadHeight = BASE_ROWS * 2 * TRI_HEIGHT;
        const octaHeight = quadHeight * 2 + GAP;

        if (displayMode === 'single') {
          width = polyWidth;
          height = BASE_ROWS * TRI_HEIGHT;
        } else if (displayMode === 'dual') {
          width = polyWidth;
          height = BASE_ROWS * 2 * TRI_HEIGHT;
        } else if (displayMode === 'quad') {
          width = polyWidth * 2;
          height = BASE_ROWS * 2 * TRI_HEIGHT;
        } else if (displayMode === 'octa') {
          width = polyWidth * 4;
          height = quadHeight * 2 + GAP;
        } else if (displayMode === 'square') {
          width = polyWidth * 4;
          height = octaHeight * 2 + GAP;
        } else if (displayMode === 'square256') {
          const squareWidth = polyWidth * 4;
          const squareHeight = octaHeight * 2 + GAP;
          const rectangleWidth = squareWidth * 4 + GAP * 3;
          const rectangleHeight = squareHeight;
          width = rectangleWidth;
          height = rectangleHeight * 4 + GAP * 3;
        } else { // rectangle
          const squareWidth = polyWidth * 4;
          const squareHeight = octaHeight * 2 + GAP;
          width = squareWidth * 4 + GAP * 3;
          height = squareHeight;
        }

        width = Math.round(width);
        height = Math.round(height);

        // Create canvas for rendering
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        // Collect frames (off-screen, doesn't affect main view)
        const frames = [];
        for (let i = 0; i < totalFrames; i++) {
          const configIdx = Math.floor(i / varCount);
          const variation = i % varCount;

          // Generate SVG content off-screen
          const svgData = generateFrameSvg(configIdx, variation, width, height);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);

          await new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              ctx.fillStyle = '#f8f8f4';
              ctx.fillRect(0, 0, width, height);
              ctx.drawImage(img, 0, 0, width, height);
              frames.push(ctx.getImageData(0, 0, width, height));
              URL.revokeObjectURL(url);
              resolve();
            };
            img.onerror = reject;
            img.src = url;
          });
        }

        // Encode GIF with current frame speed
        const gif = encodeGif(frames, width, height, Math.round(frameSpeed / 10));

        // Download
        const blob = new Blob([gif], { type: 'image/gif' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `gematria-${displayMode}-${currentPhrase.split(' ')[0]}.gif`;
        a.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error('GIF export error:', err);
        alert('Error creating GIF: ' + err.message);
      }

      btn.textContent = originalText;
      btn.disabled = false;
    });

    // GIF encoder with proper color quantization
    function encodeGif(frames, width, height, delay) {
      const buf = [];
      const write = (b) => buf.push(b);
      const writeStr = (s) => { for (let i = 0; i < s.length; i++) write(s.charCodeAt(i)); };
      const writeShort = (v) => { write(v & 0xff); write((v >> 8) & 0xff); };

      // Build global color table with better quantization
      const colorCounts = new Map();

      // Count colors across all frames
      frames.forEach(frame => {
        for (let i = 0; i < frame.data.length; i += 4) {
          // Quantize to 5 bits per channel to reduce unique colors
          const r = frame.data[i] & 0xf8;
          const g = frame.data[i+1] & 0xf8;
          const b = frame.data[i+2] & 0xf8;
          const key = (r << 16) | (g << 8) | b;
          colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
        }
      });

      // Sort by frequency and take top 256
      const sortedColors = [...colorCounts.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, 256)
        .map(([key]) => key);

      const colorMap = new Map();
      const colors = [];
      sortedColors.forEach((key, idx) => {
        colorMap.set(key, idx);
        colors.push([(key >> 16) & 0xff, (key >> 8) & 0xff, key & 0xff]);
      });
      while (colors.length < 256) colors.push([0, 0, 0]);

      // Find nearest color function
      const findNearest = (r, g, b) => {
        const qr = r & 0xf8, qg = g & 0xf8, qb = b & 0xf8;
        const key = (qr << 16) | (qg << 8) | qb;
        if (colorMap.has(key)) return colorMap.get(key);

        // Find closest color
        let minDist = Infinity, closest = 0;
        for (let i = 0; i < colors.length; i++) {
          const dr = r - colors[i][0], dg = g - colors[i][1], db = b - colors[i][2];
          const dist = dr*dr + dg*dg + db*db;
          if (dist < minDist) { minDist = dist; closest = i; }
        }
        return closest;
      };

      // Header
      writeStr('GIF89a');
      writeShort(width);
      writeShort(height);
      write(0xf7); // GCT flag, 8 bits color
      write(0);    // BG color
      write(0);    // Aspect ratio

      // Global Color Table
      colors.forEach(([r, g, b]) => { write(r); write(g); write(b); });

      // Netscape extension for looping
      write(0x21); write(0xff); write(0x0b);
      writeStr('NETSCAPE2.0');
      write(0x03); write(0x01);
      writeShort(0); // Loop forever
      write(0x00);

      // Frames
      frames.forEach(frame => {
        // Graphics Control Extension
        write(0x21); write(0xf9); write(0x04);
        write(0x00); // No transparency
        writeShort(delay);
        write(0x00); write(0x00);

        // Image Descriptor
        write(0x2c);
        writeShort(0); writeShort(0);
        writeShort(width); writeShort(height);
        write(0x00); // No local color table

        // Image Data with LZW
        const minCodeSize = 8;
        write(minCodeSize);

        const pixels = [];
        for (let i = 0; i < frame.data.length; i += 4) {
          pixels.push(findNearest(frame.data[i], frame.data[i+1], frame.data[i+2]));
        }

        const lzwData = lzwEncode(pixels, minCodeSize);
        for (let i = 0; i < lzwData.length; i += 255) {
          const chunk = lzwData.slice(i, i + 255);
          write(chunk.length);
          chunk.forEach(b => write(b));
        }
        write(0x00);
      });

      write(0x3b); // Trailer
      return new Uint8Array(buf);
    }

    function lzwEncode(pixels, minCodeSize) {
      const clearCode = 1 << minCodeSize;
      const eoiCode = clearCode + 1;
      let codeSize = minCodeSize + 1;
      let nextCode = eoiCode + 1;
      const table = new Map();
      for (let i = 0; i < clearCode; i++) table.set(String(i), i);

      const output = [];
      let bits = 0, bitCount = 0;
      const emit = (code) => {
        bits |= code << bitCount;
        bitCount += codeSize;
        while (bitCount >= 8) {
          output.push(bits & 0xff);
          bits >>= 8;
          bitCount -= 8;
        }
      };

      emit(clearCode);
      if (pixels.length === 0) {
        emit(eoiCode);
        if (bitCount > 0) output.push(bits & 0xff);
        return output;
      }

      let prefix = String(pixels[0]);

      for (let i = 1; i < pixels.length; i++) {
        const suffix = String(pixels[i]);
        const combined = prefix + ',' + suffix;
        if (table.has(combined)) {
          prefix = combined;
        } else {
          emit(table.get(prefix));
          if (nextCode < 4096) {
            table.set(combined, nextCode++);
            if (nextCode > (1 << codeSize) && codeSize < 12) codeSize++;
          } else {
            // Clear table when full
            emit(clearCode);
            table.clear();
            for (let j = 0; j < clearCode; j++) table.set(String(j), j);
            nextCode = eoiCode + 1;
            codeSize = minCodeSize + 1;
          }
          prefix = suffix;
        }
      }
      emit(table.get(prefix));
      emit(eoiCode);
      if (bitCount > 0) output.push(bits & 0xff);
      return output;
    }

    // HTML Export - standalone animated file
    document.getElementById('exportHtml').addEventListener('click', () => {
      const htmlContent = generateStandaloneHtml();
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `gematria-${displayMode}-${currentPhrase.split(' ')[0]}.html`;
      a.click();
      URL.revokeObjectURL(url);
    });

    function generateStandaloneHtml() {
      const config = CONFIGS[CONFIG_KEYS[currentConfigIndex]];
      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gematria - ${currentPhrase}</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #f5f5f0; display: flex; align-items: center; justify-content: center; min-height: 100vh; }
    svg { max-width: 95vw; max-height: 95vh; border: 2px solid #333; background: #f8f8f4; }
  </style>
</head>
<body>
  <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
  <script>
    const TRI_SIZE = 32;
    const TRI_HEIGHT = TRI_SIZE * Math.sqrt(3) / 2;
    const COLS = 9;
    const BASE_ROWS = 3;
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const ROW_COLORS = { 0: '#c41e3a', 1: '#2e8b57', 2: '#1e4d8c' };
    const phrase = ${JSON.stringify(currentPhrase)};
    const combo = ${JSON.stringify(currentCombo)};
    const displayMode = ${JSON.stringify(displayMode)};
    const frameSpeed = ${frameSpeed};
    const CONFIG_KEYS = ${JSON.stringify(CONFIG_KEYS)};
    const CONFIGS = {
      ${CONFIG_KEYS.map(key => `'${key}': { name: '${key}', getSymbol: ${CONFIGS[key].getSymbol.toString()} }`).join(',\n      ')}
    };

    let currentConfigIndex = 0;
    let currentVariation = 0;

    function getLetterFrequency(p) {
      const freq = {};
      const clean = p.toUpperCase().replace(/[^A-Z]/g, '');
      for (const c of clean) freq[c] = (freq[c] || 0) + 1;
      const maxFreq = Math.max(...Object.values(freq), 1);
      return { freq, maxFreq };
    }

    function getLetterOpacity(symbol, ld) {
      if (symbol === '*') return 0.15;
      const count = ld.freq[symbol] || 0;
      if (count === 0) return 0.15;
      return 0.3 + (count / ld.maxFreq) * 0.7;
    }

    function isLetterInPhrase(symbol, ld) {
      return symbol !== '*' && (ld.freq[symbol] || 0) > 0;
    }

    function comboToCMYK(c) {
      const toP = v => Math.round((v % 1000) / 10);
      return { c: toP(c[0]), m: toP(c[1]), y: toP(c[2]), k: toP(c[3]) };
    }

    function cmykToHex(c, m, y, k) {
      c /= 100; m /= 100; y /= 100; k /= 100;
      const r = Math.round(255 * (1-c) * (1-k));
      const g = Math.round(255 * (1-m) * (1-k));
      const b = Math.round(255 * (1-y) * (1-k));
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
    }

    function generateBasePolyhedron() {
      const t = [];
      for (let row = 0; row < BASE_ROWS; row++)
        for (let col = 0; col < COLS; col++)
          t.push({ row, col, pointing: col % 2 === 0 ? 'up' : 'down', index: row * COLS + col, polyhedronRow: row });
      return t;
    }

    ${buildSingle.toString()}
    ${buildDualStacked.toString()}
    ${buildQuadMirrored.toString()}
    ${buildOcta.toString()}
    ${buildSquare.toString()}

    function getTrianglePath(x, y, pointing) {
      const hw = TRI_SIZE / 2;
      if (pointing === 'up') return \`M \${x} \${y + TRI_HEIGHT} L \${x + hw} \${y} L \${x + TRI_SIZE} \${y + TRI_HEIGHT} Z\`;
      return \`M \${x} \${y} L \${x + TRI_SIZE} \${y} L \${x + hw} \${y + TRI_HEIGHT} Z\`;
    }

    function getVariationCount() {
      if (displayMode === 'square' || displayMode === 'octa' || displayMode === 'quad') return 2;
      return 1;
    }

    function render() {
      const svg = document.getElementById('svg');
      const config = CONFIGS[CONFIG_KEYS[currentConfigIndex]];
      const cmyk = comboToCMYK(combo);
      const hex = cmykToHex(cmyk.c, cmyk.m, cmyk.y, cmyk.k);
      const ld = getLetterFrequency(phrase);
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      let triangles, totalWidth, totalHeight;

      if (displayMode === 'single') { triangles = buildSingle(); totalWidth = polyWidth; totalHeight = BASE_ROWS * TRI_HEIGHT; }
      else if (displayMode === 'dual') { triangles = buildDualStacked(); totalWidth = polyWidth; totalHeight = BASE_ROWS * 2 * TRI_HEIGHT; }
      else if (displayMode === 'square') { triangles = buildSquare(currentVariation); const GAP = 8; const qh = BASE_ROWS * 2 * TRI_HEIGHT; const oh = qh * 2 + GAP; totalWidth = polyWidth * 4; totalHeight = oh * 2 + GAP; }
      else if (displayMode === 'octa') { triangles = buildOcta(currentVariation); totalWidth = polyWidth * 4; totalHeight = BASE_ROWS * 4 * TRI_HEIGHT + 8; }
      else { triangles = buildQuadMirrored(currentVariation); totalWidth = polyWidth * 2; totalHeight = BASE_ROWS * 2 * TRI_HEIGHT; }

      svg.setAttribute('viewBox', \`0 0 \${totalWidth} \${totalHeight}\`);
      let content = \`<rect x="0" y="0" width="\${totalWidth}" height="\${totalHeight}" fill="#f8f8f4"/>\`;

      triangles.forEach(tri => {
        const symbol = config.getSymbol(tri.index % 27);
        const opacity = getLetterOpacity(symbol, ld);
        const inPhrase = isLetterInPhrase(symbol, ld);
        const fill = inPhrase ? hex : '#f8f8f4';
        const fillOp = inPhrase ? opacity : 0.08;
        const path = getTrianglePath(tri.x, tri.y, tri.pointing);
        content += \`<path d="\${path}" fill="\${fill}" fill-opacity="\${fillOp}" stroke="#333" stroke-width="1"/>\`;
        const tx = tri.x + TRI_SIZE / 2;
        const ty = tri.y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);
        const textColor = inPhrase ? '#ffffff' : '#000000';
        content += \`<text x="\${tx}" y="\${ty}" text-anchor="middle" dominant-baseline="middle" font-family="Arial" font-size="9" font-weight="bold" fill="\${textColor}" fill-opacity="\${opacity}">\${symbol}</text>\`;
      });
      svg.innerHTML = content;
    }

    function animate() {
      const varCount = getVariationCount();
      if (varCount > 1) {
        currentVariation++;
        if (currentVariation >= varCount) { currentVariation = 0; currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length; }
      } else { currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length; }
      render();
      setTimeout(animate, frameSpeed);
    }

    render();
    setTimeout(animate, frameSpeed);
  <\/script>
</body>
</html>`;
    }

    // Background animation state
    let bgColumns = [];
    let bgTileHeight = 0;
    let bgAnimationId = null;
    let bgLastTime = 0;

    // Render tiled background with animated columns
    function renderBackground() {
      const bgSvg = document.getElementById('backgroundSvg');
      const config = CONFIGS[CONFIG_KEYS[0]]; // Use first config (a-*-z)
      const color = getColor();
      const letterData = getLetterFrequency(currentPhrase);

      // Build quad triangles for one tile
      const triangles = buildQuadMirrored(0); // Use Normal variation
      const polyWidth = (COLS - 1) * (TRI_SIZE / 2) + TRI_SIZE;
      const tileWidth = polyWidth * 2;
      bgTileHeight = BASE_ROWS * 2 * TRI_HEIGHT;

      // Calculate how many tiles needed to cover screen
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const tilesX = Math.ceil(screenWidth / tileWidth) + 2;
      const tilesY = Math.ceil(screenHeight / bgTileHeight) + 3;

      const totalWidth = tilesX * tileWidth;

      bgSvg.setAttribute('viewBox', `0 0 ${totalWidth} ${screenHeight}`);

      // Build tile content
      let tileContent = '';
      triangles.forEach(tri => {
        const symbol = config.getSymbol(tri.index % 27);
        const letterOpacity = getLetterOpacity(symbol, letterData);

        const isInPhrase = isLetterInPhrase(symbol, letterData);
        const fill = isInPhrase ? color.hex : '#f8f8f4';
        const fillOpacity = isInPhrase ? letterOpacity : 0.08;

        const path = getTrianglePath(tri.x, tri.y, tri.pointing);
        tileContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#999" stroke-width="0.5"/>`;

        const textX = tri.x + TRI_SIZE / 2;
        const textY = tri.y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);

        // White text on colored bg, black text on white bg
        const textColor = isInPhrase ? '#ffffff' : '#000000';

        tileContent += `<text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                             font-family="Arial" font-size="9" font-weight="bold"
                             fill="${textColor}" fill-opacity="${letterOpacity * 0.7}">${symbol}</text>`;
      });

      let svgContent = `<rect x="0" y="0" width="${totalWidth}" height="${screenHeight}" fill="#f5f5f0"/>`;

      // Create pattern for reuse
      svgContent += `<defs><g id="tile">${tileContent}</g></defs>`;

      // Create columns (no CSS animation - we'll animate with JS)
      // Initialize column positions if needed
      const totalColumnHeight = tilesY * bgTileHeight;
      if (bgColumns.length !== tilesX) {
        bgColumns = [];
        const staggerOffset = totalColumnHeight / 3;
        for (let col = 0; col < tilesX; col++) {
          const goingUp = col % 2 === 0;
          const yFlip = col % 2 === 1;
          // Stagger alternating columns by 1/3 of total column height
          const baseOffset = goingUp ? 0 : -bgTileHeight;
          const stagger = (col % 2) * staggerOffset;
          bgColumns.push({
            direction: goingUp ? -1 : 1, // -1 = up, 1 = down
            offset: baseOffset - stagger,
            yFlip: yFlip,
            xPos: col * tileWidth,
            tileWidth: tileWidth
          });
        }
      }

      for (let col = 0; col < tilesX; col++) {
        const xPos = col * tileWidth;
        // Y-flip every other column (2nd, 4th, 6th = indices 1, 3, 5)
        const yFlip = col % 2 === 1;
        const flipTransform = yFlip ? `translate(${2 * xPos + tileWidth}, 0) scale(-1, 1)` : '';
        svgContent += `<g id="bgCol${col}" ${yFlip ? `transform="${flipTransform}"` : ''}>`;
        for (let row = -1; row < tilesY; row++) {
          const yPos = row * bgTileHeight;
          svgContent += `<use href="#tile" x="${xPos}" y="${yPos}"/>`;
        }
        svgContent += `</g>`;
      }

      bgSvg.innerHTML = svgContent;

      // Start background animation loop if not running
      if (!bgAnimationId) {
        bgLastTime = performance.now();
        bgAnimationId = requestAnimationFrame(animateBackground);
      }
    }

    // JavaScript-based background animation
    function animateBackground(currentTime) {
      const deltaTime = currentTime - bgLastTime;
      bgLastTime = currentTime;

      // Speed: pixels per millisecond (based on frameSpeed)
      // At frameSpeed=666, scroll speed should be moderate
      const scrollSpeed = bgTileHeight / (Math.max(3, frameSpeed / 20) * 1000);

      bgColumns.forEach((col, i) => {
        col.offset += col.direction * scrollSpeed * deltaTime;

        // Wrap around
        if (col.offset <= -bgTileHeight) col.offset += bgTileHeight;
        if (col.offset >= 0) col.offset -= bgTileHeight;

        const colEl = document.getElementById(`bgCol${i}`);
        if (colEl) {
          // Combine scroll transform with Y-flip if needed
          if (col.yFlip) {
            colEl.setAttribute('transform', `translate(${2 * col.xPos + col.tileWidth}, ${col.offset}) scale(-1, 1)`);
          } else {
            colEl.setAttribute('transform', `translate(0, ${col.offset})`);
          }
        }
      });

      bgAnimationId = requestAnimationFrame(animateBackground);
    }

    // Update background scroll speed - now a no-op since JS animation reads frameSpeed directly
    function updateBackgroundSpeed() {
      // Speed changes are picked up automatically by animateBackground
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      render();
      renderBackground();
    });

    // Initialize - set frameSpeed from default phrase's aik bekar value
    const initialAikBekar = currentCombo[currentCombo.length - 1];
    frameSpeed = aikBekarToMs(initialAikBekar);
    document.getElementById('frameSpeed').value = frameSpeed.toFixed(2);

    render();
    renderBackground();
    animate();
  </script>
</body>
</html>
