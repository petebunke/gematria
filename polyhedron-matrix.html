<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Gematria Polyhedron Tessellation</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f0;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .controls-overlay {
      background: rgba(255,255,255,0.95);
      border-bottom: 2px solid #333;
      padding: 8px 16px;
      width: 100%;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .control-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
    }

    select, button, input {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      color: #333;
      padding: 4px 6px;
      font-size: 11px;
    }

    input[type="number"] {
      width: 60px;
    }

    button {
      background: #6b5b95;
      border-color: #6b5b95;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #5a4a84; }
    button.secondary {
      background: #fff;
      color: #6b5b95;
      border-color: #6b5b95;
    }

    .info-display {
      font-family: monospace;
      font-size: 10px;
      background: #f0f0e8;
      padding: 2px 5px;
      border-radius: 4px;
    }

    .color-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid #333;
    }

    .tessellation-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
      padding: 20px;
    }

    #tessellationSvg {
      width: 400px;
      height: 300px;
      touch-action: none;
      border: 2px solid #333;
      background: #f8f8f4;
    }
  </style>
</head>
<body>
  <div class="controls-overlay">
    <div class="control-group">
      <span class="control-label">Phrase</span>
      <select id="phraseSelect">
        <option value="stunner|555/666/111/111">stunner (555/666/111/111)</option>
        <option value="which|111/666/111/99">which (111/666/111/99)</option>
        <option value="act shah high|333/666/111/99">act shah high (333/666/111/99)</option>
        <option value="xbox add salad|777/666/111/99">xbox add salad (777/666/111/99)</option>
        <option value="hiawatha|1111/666/111/99">hiawatha (1111/666/111/99)</option>
        <option value="therapeutic|8888/6666/1111/1111">therapeutic (8888/6666/1111/1111)</option>
      </select>
    </div>

    <div class="control-group">
      <span class="control-label">Mode</span>
      <select id="displayMode">
        <option value="quad">Quad (Mirrored Pairs)</option>
        <option value="dual">Dual (Stacked)</option>
      </select>
    </div>

    <div class="control-group">
      <span class="control-label">Config</span>
      <span class="info-display" id="configName">a-*-z</span>
    </div>

    <div class="control-group">
      <span class="control-label">Var</span>
      <span class="info-display" id="variationName" style="width: 52px; text-align: center;">Normal</span>
    </div>

    <div class="control-group">
      <span class="control-label">Speed</span>
      <input type="number" id="frameSpeed" value="333.333" min="1" max="5000" step="0.001">
      <span class="control-label">ms</span>
    </div>

    <div class="control-group">
      <span class="control-label">CMYK</span>
      <span class="info-display" id="cmykInfo">56/67/11/11</span>
      <div class="color-swatch" id="colorSwatch"></div>
    </div>

    <div class="control-group">
      <button id="playPause">⏸</button>
      <button id="prevVar" class="secondary">◀</button>
      <button id="nextVar" class="secondary">▶</button>
    </div>

    <div class="control-group">
      <span class="control-label">Zoom</span>
      <span class="info-display" id="zoomLevel">100%</span>
    </div>

    <div class="control-group">
      <button id="exportSvg" class="secondary">SVG</button>
    </div>
  </div>

  <div class="tessellation-container" id="container">
    <svg id="tessellationSvg" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <script>
    // Constants
    const TRI_SIZE = 32;
    const TRI_HEIGHT = TRI_SIZE * Math.sqrt(3) / 2;
    const COLS = 9;      // Triangles per row in base polyhedron
    const BASE_ROWS = 3; // Base polyhedron rows

    // Alphabet
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // Row colors for polyhedron (by row position)
    const ROW_COLORS = {
      0: '#c41e3a', // Row 1: Red
      1: '#2e8b57', // Row 2: Green
      2: '#1e4d8c'  // Row 3: Blue
    };

    // 6 configurations
    const CONFIGS = {
      'a-*-z': {
        name: 'a-*-z',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[pos];
          if (pos === 13) return '*';
          return ALPHABET[pos - 1];
        }
      },
      '*-a-z': {
        name: '*-a-z',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[pos - 1];
        }
      },
      'a-z-*': {
        name: 'a-z-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[pos];
        }
      },
      'z-*-a': {
        name: 'z-*-a',
        getSymbol: (pos) => {
          if (pos < 13) return ALPHABET[25 - pos];
          if (pos === 13) return '*';
          return ALPHABET[25 - (pos - 1)];
        }
      },
      '*-z-a': {
        name: '*-z-a',
        getSymbol: (pos) => {
          if (pos === 0) return '*';
          return ALPHABET[26 - pos];
        }
      },
      'z-a-*': {
        name: 'z-a-*',
        getSymbol: (pos) => {
          if (pos === 26) return '*';
          return ALPHABET[25 - pos];
        }
      }
    };

    const CONFIG_KEYS = Object.keys(CONFIGS);

    // State
    let currentPhrase = 'stunner';
    let currentCombo = [555, 666, 111, 111];
    let currentConfigIndex = 0;
    let currentVariation = 0; // 0 = normal, 1 = inverted
    let isPlaying = true;
    let animationTimer = null;
    let frameSpeed = 333.333;
    let displayMode = 'quad'; // 'quad' or 'dual'

    // Zoom state
    let scale = 1;
    let initialDistance = 0;
    let initialScale = 1;

    // Check if a letter is in the phrase
    function isLetterInPhrase(symbol, letterData) {
      return symbol !== '*' && (letterData.freq[symbol] || 0) > 0;
    }

    // Calculate letter frequency in phrase
    function getLetterFrequency(phrase) {
      const freq = {};
      const cleanPhrase = phrase.toUpperCase().replace(/[^A-Z]/g, '');

      for (const char of cleanPhrase) {
        freq[char] = (freq[char] || 0) + 1;
      }

      const maxFreq = Math.max(...Object.values(freq), 1);
      return { freq, maxFreq, totalLetters: cleanPhrase.length };
    }

    // Get opacity for a letter based on frequency
    function getLetterOpacity(symbol, letterData) {
      if (symbol === '*') {
        return 0.15;
      }

      const { freq, maxFreq } = letterData;
      const count = freq[symbol] || 0;

      if (count === 0) {
        return 0.15;
      }

      const baseOpacity = 0.3;
      const normalized = count / maxFreq;
      return baseOpacity + normalized * (1 - baseOpacity);
    }

    // Get letter color by ROW POSITION in polyhedron
    function getLetterColor(polyhedronRow) {
      return ROW_COLORS[polyhedronRow % 3];
    }

    // CMYK conversion
    function comboToCMYK(combo) {
      const toPercent = (val) => Math.round((val % 1000) / 10);
      return {
        c: toPercent(combo[0]),
        m: toPercent(combo[1]),
        y: toPercent(combo[2]),
        k: toPercent(combo[3])
      };
    }

    function cmykToRgb(c, m, y, k) {
      c /= 100; m /= 100; y /= 100; k /= 100;
      return {
        r: Math.round(255 * (1 - c) * (1 - k)),
        g: Math.round(255 * (1 - m) * (1 - k)),
        b: Math.round(255 * (1 - y) * (1 - k))
      };
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function getColor() {
      const cmyk = comboToCMYK(currentCombo);
      const rgb = cmykToRgb(cmyk.c, cmyk.m, cmyk.y, cmyk.k);
      return { cmyk, rgb, hex: rgbToHex(rgb.r, rgb.g, rgb.b) };
    }

    // Generate base 3-row polyhedron triangles
    function generateBasePolyhedron() {
      const triangles = [];
      for (let row = 0; row < BASE_ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          triangles.push({
            row,
            col,
            pointing: col % 2 === 0 ? 'up' : 'down',
            index: row * COLS + col,
            polyhedronRow: row
          });
        }
      }
      return triangles;
    }

    // Build dual mode: same as quad polyhedron structure but single column
    // Top: original, Bottom: X-mirrored (same as quad's right column)
    function buildDualStacked() {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      const polyWidth = COLS * (TRI_SIZE / 2);

      // Top half: original (same as quad top-right)
      base.forEach(t => {
        const x = t.col * (TRI_SIZE / 2);
        const y = t.row * TRI_HEIGHT;

        allTriangles.push({
          ...t,
          x,
          y,
          yMirror: false
        });
      });

      // Bottom half: X-mirrored rows, then Y-mirrored (horizontal flip)
      // Same structure as quad's bottom-right quadrant
      base.forEach(t => {
        // X-mirror: reverse rows
        const xMirroredRow = BASE_ROWS - 1 - t.row;
        // Y-mirror: reverse columns and flip pointing
        const col = COLS - 1 - t.col;
        const pointing = t.pointing === 'up' ? 'down' : 'up';

        const x = col * (TRI_SIZE / 2);
        const y = (BASE_ROWS + xMirroredRow) * TRI_HEIGHT;

        allTriangles.push({
          ...t,
          col,
          pointing,
          polyhedronRow: BASE_ROWS - 1 - t.polyhedronRow,
          x,
          y,
          yMirror: true
        });
      });

      return allTriangles;
    }

    // Build quad mode: mirrored polycolumn pairs
    // Top half: left Y-mirrored, right original
    // Bottom half: left Y-mirrored + Y-flipped, right Y-flipped (horizontal flip for bottom)
    // variation 0 = Normal: [base on top, X-mirror below]
    // variation 1 = Inverted: [X-mirror on top, base below]
    function buildQuadMirrored(variation) {
      const base = generateBasePolyhedron();
      const allTriangles = [];

      const polyWidth = COLS * (TRI_SIZE / 2);
      const polyHeight = BASE_ROWS * TRI_HEIGHT;

      // Two columns: left (Y-mirrored) and right (original)
      const columns = [
        { colIndex: 0, yMirror: true },   // Left: Y-mirrored
        { colIndex: 1, yMirror: false }   // Right: Original
      ];

      columns.forEach(({ colIndex, yMirror }) => {
        // For each column, build a polycolumn (6 rows):
        // Normal (variation 0): top = original rows, bottom = X-reflected rows
        // Inverted (variation 1): top = X-reflected rows, bottom = original rows

        // Top half
        base.forEach(t => {
          let col = t.col;
          let pointing = t.pointing;
          let row, polyRow;

          if (variation === 0) {
            // Normal: original on top
            row = t.row;
            polyRow = t.polyhedronRow;
          } else {
            // Inverted: X-reflected on top (rows reversed)
            row = BASE_ROWS - 1 - t.row;
            polyRow = BASE_ROWS - 1 - t.polyhedronRow;
          }

          if (yMirror) {
            col = COLS - 1 - col;
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          const x = colIndex * polyWidth + col * (TRI_SIZE / 2);
          const y = row * TRI_HEIGHT;

          allTriangles.push({
            ...t,
            col,
            pointing,
            polyhedronRow: polyRow,
            x,
            y,
            yMirror,
            section: 'top'
          });
        });

        // Bottom half: also Y-mirrored (horizontal flip)
        base.forEach(t => {
          let col = t.col;
          let pointing = t.pointing;
          let row, polyRow;

          if (variation === 0) {
            // Normal: X-reflected on bottom (rows reversed)
            row = BASE_ROWS + (BASE_ROWS - 1 - t.row);
            polyRow = BASE_ROWS - 1 - t.polyhedronRow;
          } else {
            // Inverted: original on bottom
            row = BASE_ROWS + t.row;
            polyRow = t.polyhedronRow;
          }

          // Bottom half is Y-mirrored (horizontal flip)
          // If column was already Y-mirrored, this un-mirrors it
          // If column was not Y-mirrored, this mirrors it
          const bottomYMirror = !yMirror;
          if (bottomYMirror) {
            col = COLS - 1 - col;
            pointing = pointing === 'up' ? 'down' : 'up';
          }

          const x = colIndex * polyWidth + col * (TRI_SIZE / 2);
          const y = row * TRI_HEIGHT;

          allTriangles.push({
            ...t,
            col,
            pointing,
            polyhedronRow: polyRow,
            x,
            y,
            yMirror: bottomYMirror,
            section: 'bottom'
          });
        });
      });

      return allTriangles;
    }

    // Get triangle path
    function getTrianglePath(x, y, pointing) {
      const halfWidth = TRI_SIZE / 2;
      if (pointing === 'up') {
        return `M ${x} ${y + TRI_HEIGHT} L ${x + halfWidth} ${y} L ${x + TRI_SIZE} ${y + TRI_HEIGHT} Z`;
      } else {
        return `M ${x} ${y} L ${x + TRI_SIZE} ${y} L ${x + halfWidth} ${y + TRI_HEIGHT} Z`;
      }
    }

    // Render
    function render() {
      const svg = document.getElementById('tessellationSvg');
      const config = CONFIGS[CONFIG_KEYS[currentConfigIndex]];
      const color = getColor();
      const letterData = getLetterFrequency(currentPhrase);

      // Update UI
      document.getElementById('configName').textContent = config.name;
      document.getElementById('variationName').textContent =
        displayMode === 'quad' ? (currentVariation === 0 ? 'Normal' : 'Inverted') : '-';
      document.getElementById('cmykInfo').textContent =
        `${color.cmyk.c}/${color.cmyk.m}/${color.cmyk.y}/${color.cmyk.k}`;
      document.getElementById('colorSwatch').style.backgroundColor = color.hex;
      document.getElementById('zoomLevel').textContent = `${Math.round(scale * 100)}%`;

      // Build triangles based on mode
      let triangles;
      let totalWidth, totalHeight;

      const polyWidth = COLS * (TRI_SIZE / 2);

      if (displayMode === 'dual') {
        triangles = buildDualStacked();
        totalWidth = polyWidth;
        totalHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      } else {
        triangles = buildQuadMirrored(currentVariation);
        totalWidth = polyWidth * 2;
        totalHeight = BASE_ROWS * 2 * TRI_HEIGHT;
      }

      // Apply zoom via viewBox only (SVG stays fixed size in container)
      const viewWidth = totalWidth / scale;
      const viewHeight = totalHeight / scale;
      const viewX = (totalWidth - viewWidth) / 2;
      const viewY = (totalHeight - viewHeight) / 2;

      svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewWidth} ${viewHeight}`);

      let svgContent = `<rect x="0" y="0" width="${totalWidth}" height="${totalHeight}" fill="#f8f8f4"/>`;

      // Draw all triangles
      triangles.forEach(tri => {
        const symbol = config.getSymbol(tri.index % 27);
        const letterOpacity = getLetterOpacity(symbol, letterData);
        const letterColor = getLetterColor(tri.polyhedronRow);

        const isInPhrase = isLetterInPhrase(symbol, letterData);
        const fill = isInPhrase ? color.hex : '#f8f8f4';
        const fillOpacity = isInPhrase ? letterOpacity : 0.08;

        const path = getTrianglePath(tri.x, tri.y, tri.pointing);
        svgContent += `<path d="${path}" fill="${fill}" fill-opacity="${fillOpacity}" stroke="#333" stroke-width="1"/>`;

        // Text positioning
        const textX = tri.x + TRI_SIZE / 2;
        const textY = tri.y + (tri.pointing === 'up' ? TRI_HEIGHT * 0.6 : TRI_HEIGHT * 0.4);

        // Mirror text for Y-mirrored sections
        const textTransform = tri.yMirror
          ? `translate(${textX * 2}, 0) scale(-1, 1)`
          : '';

        svgContent += `<text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                             font-family="Arial" font-size="9" font-weight="bold"
                             fill="${letterColor}" fill-opacity="${letterOpacity}"
                             ${textTransform ? `transform="${textTransform}"` : ''}>${symbol}</text>`;
      });

      svg.innerHTML = svgContent;
    }

    // Animation - cycles through all 12 variations (6 configs × 2 variations)
    function animate() {
      if (!isPlaying) return;

      if (displayMode === 'quad') {
        // Cycle through variation first, then config
        currentVariation++;
        if (currentVariation >= 2) {
          currentVariation = 0;
          currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length;
        }
      } else {
        // Dual mode: just cycle configs
        currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length;
      }

      render();
      animationTimer = setTimeout(animate, frameSpeed);
    }

    // Get total variation index (0-11 for quad mode)
    function getTotalVariationIndex() {
      return currentConfigIndex * 2 + currentVariation;
    }

    // Set from total variation index
    function setFromTotalVariationIndex(idx) {
      const total = CONFIG_KEYS.length * 2;
      idx = ((idx % total) + total) % total;
      currentConfigIndex = Math.floor(idx / 2);
      currentVariation = idx % 2;
    }

    // Pinch zoom handling
    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    const container = document.getElementById('container');

    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        initialDistance = getDistance(e.touches);
        initialScale = scale;
      }
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getDistance(e.touches);
        const newScale = initialScale * (currentDistance / initialDistance);
        scale = Math.max(0.5, Math.min(5, newScale));
        render();
      }
    }, { passive: false });

    // Mouse wheel zoom
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      scale = Math.max(0.5, Math.min(5, scale * zoomFactor));
      render();
    }, { passive: false });

    // Event handlers
    document.getElementById('playPause').addEventListener('click', () => {
      isPlaying = !isPlaying;
      document.getElementById('playPause').textContent = isPlaying ? '⏸' : '▶';
      if (isPlaying) animate();
      else if (animationTimer) clearTimeout(animationTimer);
    });

    document.getElementById('prevVar').addEventListener('click', () => {
      if (displayMode === 'quad') {
        setFromTotalVariationIndex(getTotalVariationIndex() - 1);
      } else {
        currentConfigIndex = (currentConfigIndex - 1 + CONFIG_KEYS.length) % CONFIG_KEYS.length;
      }
      render();
    });

    document.getElementById('nextVar').addEventListener('click', () => {
      if (displayMode === 'quad') {
        setFromTotalVariationIndex(getTotalVariationIndex() + 1);
      } else {
        currentConfigIndex = (currentConfigIndex + 1) % CONFIG_KEYS.length;
      }
      render();
    });

    document.getElementById('phraseSelect').addEventListener('change', (e) => {
      const [phrase, combo] = e.target.value.split('|');
      currentPhrase = phrase;
      currentCombo = combo.split('/').map(Number);
      render();
    });

    document.getElementById('displayMode').addEventListener('change', (e) => {
      displayMode = e.target.value;
      currentVariation = 0;
      render();
    });

    document.getElementById('frameSpeed').addEventListener('input', (e) => {
      frameSpeed = parseFloat(e.target.value) || 333.333;
      if (isPlaying && animationTimer) {
        clearTimeout(animationTimer);
        animationTimer = setTimeout(animate, frameSpeed);
      }
    });

    document.getElementById('exportSvg').addEventListener('click', () => {
      const svg = document.getElementById('tessellationSvg');
      const svgData = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const varName = displayMode === 'quad' ? (currentVariation === 0 ? 'normal' : 'inverted') : 'stacked';
      a.download = `gematria-${CONFIG_KEYS[currentConfigIndex]}-${varName}.svg`;
      a.click();
      URL.revokeObjectURL(url);
    });

    // Handle window resize
    window.addEventListener('resize', render);

    // Initialize
    render();
    animate();
  </script>
</body>
</html>
